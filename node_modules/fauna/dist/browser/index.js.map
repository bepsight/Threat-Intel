{
  "version": 3,
  "sources": ["../../node_modules/base64-js/index.js", "../../src/client-configuration.ts", "../../src/errors.ts", "../../src/http-client/paths.ts", "../../src/http-client/fetch-client.ts", "../../src/http-client/node-http2-client.ts", "../../src/http-client/index.ts", "../../src/tagged-type.ts", "../../src/regex.ts", "../../src/values/date-time.ts", "../../src/values/doc.ts", "../../src/values/set.ts", "../../src/values/stream.ts", "../../src/query-builder.ts", "../../src/util/package-version.ts", "../../src/util/environment.ts", "../../src/util/retryable.ts", "../../src/wire-protocol.ts", "../../src/client.ts"],
  "sourcesContent": ["'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n", "import { HTTPClient, HTTPStreamClient } from \"./http-client\";\nimport type { ValueFormat } from \"./wire-protocol\";\n\n/**\n * Configuration for a client. The options provided are used as the\n * default options for each query.\n */\nexport interface ClientConfiguration {\n  /**\n   * Time in milliseconds beyond {@link ClientConfiguration.query_timeout_ms} at\n   * which the client will abort a request if it has not received a response.\n   * The default is 5000 ms, which should account for network latency for most\n   * clients. The value must be greater than zero. The closer to zero the value\n   * is, the more likely the client is to abort the request before the server\n   * can report a legitimate response or error.\n   */\n  client_timeout_buffer_ms?: number;\n\n  /**\n   * The {@link https://developer.mozilla.org/en-US/docs/Web/API/URL|URL} of Fauna to call. See {@link endpoints} for some default options.\n   */\n  endpoint?: URL;\n\n  /**\n   * Determines the encoded format expected for the query `arguments` field, and\n   * the `data` field of a successful response.\n   * @remarks **Note, it is very unlikely you need to change this value from its\n   * default.**\n   * The default format is \"tagged\", which specifies that the driver transmits\n   * type information over the wire. Type information allows the driver and\n   * Fauna to distinguish between types such as int\" and \"long\" which do not\n   * have a standard way of distinguishing in JSON.\n   * Rare use cases can also deal with standard JSON by setting the value to\n   * \"simple\". Note that the types enocodable in standard JSON are a subset of\n   * the types encodable in the default \"tagged\" format.\n   * It is not recommended that users use the \"simple\" format as you will lose\n   * the typing of your data. e.g. a \"Date\" will no longer be recognized by the\n   * Fauna as a \"Date\", but will instead be treated as a string.\n   */\n  format?: ValueFormat;\n\n  /**\n   * Time in milliseconds the client will keep an HTTP2 session open after all\n   * requests are completed. The default is 5000 ms.\n   */\n  http2_session_idle_ms?: number;\n\n  /**\n   * The maximum number of HTTP2 streams to execute in parallel\n   * to Fauna per HTTP2 session.\n   * Only relevant to certain HTTP2 clients.\n   * @remarks\n   * Relevant to clients using the {@link NodeHTTP2Client} provided,\n   * or any custom HTTP2Clients you implement that support this feature.\n   */\n  http2_max_streams?: number;\n\n  /**\n   * When true will keep executing a request even if the page\n   * that fired the request is no longer executing. Only relevant\n   * to underlying clients using the {@link https://fetch.spec.whatwg.org/ | Fetch standard}.\n   * By default set to false.\n   * @remarks\n   * Relevant to clients using the {@link FetchClient} provided,\n   * or any custom HTTP Clients you implement using the Fetch standard.\n   */\n  fetch_keepalive?: boolean;\n\n  /**\n   * A secret for your Fauna DB, used to authorize your queries.\n   * @see https://docs.fauna.com/fauna/current/security/keys\n   */\n  secret?: string;\n\n  // Query options\n\n  /**\n   * The timeout of each query, in milliseconds. This controls the maximum amount of\n   * time Fauna will execute your query before marking it failed. The default is 5000 ms.\n   */\n  query_timeout_ms?: number;\n\n  /**\n   * If true, unconditionally run the query as strictly serialized.\n   * This affects read-only transactions. Transactions which write\n   * will always be strictly serialized.\n   */\n  linearized?: boolean;\n\n  /**\n   * Controls what Javascript type to deserialize {@link https://docs.fauna.com/fauna/current/reference/fql_reference/types#long | Fauna longs} to.\n   * Use 'number' to deserialize longs to number. Use 'bigint' to deserialize to bigint. Defaults to 'number'.\n   * Note, for extremely large maginitude numbers Javascript's number will lose precision; as Javascript's\n   * 'number' can only support +/- 2^53-1 whereas Fauna's long is 64 bit. If this is detected, a warning will\n   * be logged to the console and precision loss will occur.\n   * If your application uses extremely large magnitude numbers use 'bigint'.\n   */\n  long_type?: \"number\" | \"bigint\";\n\n  /**\n   * The max number of times to retry the query if contention is encountered.\n   */\n  max_contention_retries?: number;\n\n  /**\n   * Tags provided back via logging and telemetry.\n   */\n  query_tags?: { [key: string]: string };\n\n  /**\n   * A traceparent provided back via logging and telemetry.\n   * Must match format: https://www.w3.org/TR/trace-context/#traceparent-header\n   */\n  traceparent?: string;\n\n  /**\n   * Enable or disable typechecking of the query before evaluation. If no value\n   * is provided, the value of `typechecked` in the database configuration will\n   * be used.\n   */\n  typecheck?: boolean;\n\n  /**\n   * Enable or disable performance hints. Defaults to disabled.\n   * The QueryInfo object includes performance hints in the `summary` field, which is a\n   * top-level field in the response object.\n   */\n  performance_hints?: boolean;\n\n  /**\n   * Max attempts for retryable exceptions. Default is 3.\n   */\n  max_attempts?: number;\n\n  /**\n   * Max backoff between retries. Default is 20 seconds.\n   */\n  max_backoff?: number;\n}\n\n/**\n * An extensible interface for a set of Fauna endpoints.\n * @remarks Leverage the `[key: string]: URL;` field to extend to other endpoints.\n */\nexport interface Endpoints {\n  /** Fauna's default endpoint. */\n  default: URL;\n\n  /**\n   * An endpoint for interacting with local instance of Fauna (e.g. one running in a local docker container).\n   */\n  local: URL;\n\n  /**\n   * An alias for local.\n   */\n  localhost: URL;\n\n  /**\n   * Any other endpoint you want your client to support. For example, if you run all requests through a proxy\n   * configure it here. Most clients will not need to leverage this ability.\n   */\n  [key: string]: URL;\n}\n\n/**\n * Configuration for a streaming client. This typically comes from the `Client`\n * instance configuration.\n */\nexport type StreamClientConfiguration = {\n  /**\n   * The underlying {@link HTTPStreamClient} that will execute the actual HTTP calls\n   */\n  httpStreamClient: HTTPStreamClient;\n\n  /**\n   * Controls what Javascript type to deserialize {@link https://docs.fauna.com/fauna/current/reference/fql_reference/types#long | Fauna longs} to.\n   *\n   * @see {@link ClientConfiguration.long_type}\n   */\n  long_type: \"number\" | \"bigint\";\n\n  /**\n   * Max attempts for retryable exceptions.\n   */\n  max_attempts: number;\n\n  /**\n   * Max backoff between retries.\n   */\n  max_backoff: number;\n\n  /**\n   * A secret for your Fauna DB, used to authorize your queries.\n   * @see https://docs.fauna.com/fauna/current/security/keys\n   */\n  secret: string;\n\n  /**\n   * Indicates if stream should include \"status\" events, periodic events that\n   * update the client with the latest valid timestamp (in the event of a\n   * dropped connection) as well as metrics about the cost of maintaining\n   * the stream other than the cost of the received events.\n   */\n  status_events?: boolean;\n\n  /**\n   * The last seen event cursor to resume the stream from. When provided, the\n   * stream will start from the given cursor position (exclusively).\n   */\n  cursor?: string;\n};\n\n/**\n * Configuration for an event feed client.\n */\nexport type FeedClientConfiguration = Required<\n  Pick<\n    ClientConfiguration,\n    | \"long_type\"\n    | \"max_attempts\"\n    | \"max_backoff\"\n    | \"client_timeout_buffer_ms\"\n    | \"query_timeout_ms\"\n    | \"secret\"\n  >\n> & {\n  /**\n   * The underlying {@link HTTPClient} that will execute the actual HTTP calls\n   */\n  httpClient: HTTPClient;\n\n  /**\n   * The starting timestamp of the event feed, exclusive. If set, Fauna will return events starting after\n    the timestamp.\n   */\n  start_ts?: number;\n\n  /**\n   * The starting event cursor, exclusive. If set, Fauna will return events starting after the cursor.\n   */\n  cursor?: string;\n\n  /**\n   * Maximum number of events returned per page.\n   * Must be in the range 1 to 16000 (inclusive).\n   * Defaults to 16.\n   */\n  page_size?: number;\n};\n\n/**\n * A extensible set of endpoints for calling Fauna.\n * @remarks Most clients will will not need to extend this set.\n * @example\n * ## To Extend\n * ```typescript\n *   // add to the endpoints constant\n *   endpoints.myProxyEndpoint = new URL(\"https://my.proxy.url\");\n * ```\n */\nexport const endpoints: Endpoints = {\n  default: new URL(\"https://db.fauna.com\"),\n  local: new URL(\"http://localhost:8443\"),\n  localhost: new URL(\"http://localhost:8443\"),\n};\n", "import type {\n  ConstraintFailure,\n  QueryFailure,\n  QueryInfo,\n  QueryStats,\n  QueryValue,\n} from \"./wire-protocol\";\n\n/**\n * A common error base class for all other errors.\n */\nexport abstract class FaunaError extends Error {\n  constructor(...args: any[]) {\n    super(...args);\n  }\n}\n\n/**\n * An error representing a query failure returned by Fauna.\n */\nexport class ServiceError extends FaunaError {\n  /**\n   * The HTTP Status Code of the error.\n   */\n  readonly httpStatus?: number;\n  /**\n   * A code for the error. Codes indicate the cause of the error.\n   * It is safe to write programmatic logic against the code. They are\n   * part of the API contract.\n   */\n  readonly code: string;\n  /**\n   * Details about the query sent along with the response\n   */\n  readonly queryInfo?: QueryInfo;\n  /**\n   * A machine readable description of any constraint failures encountered by the query.\n   * Present only if this query encountered constraint failures.\n   */\n  readonly constraint_failures?: Array<ConstraintFailure>;\n\n  constructor(failure: QueryFailure, httpStatus?: number) {\n    super(failure.error.message);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ServiceError);\n    }\n\n    this.name = \"ServiceError\";\n    this.code = failure.error.code;\n    this.httpStatus = httpStatus;\n\n    const info: QueryInfo = {\n      txn_ts: failure.txn_ts,\n      summary: failure.summary,\n      query_tags: failure.query_tags,\n      stats: failure.stats,\n    };\n    this.queryInfo = info;\n\n    this.constraint_failures = failure.error.constraint_failures;\n  }\n}\n\n/**\n * An error response that is the result of the query failing during execution.\n * QueryRuntimeError's occur when a bug in your query causes an invalid execution\n * to be requested.\n * The 'code' field will vary based on the specific error cause.\n */\nexport class QueryRuntimeError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus?: number) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, QueryRuntimeError);\n    }\n    this.name = \"QueryRuntimeError\";\n    // TODO trace, txn_ts, and stats not yet returned for QueryRuntimeError\n    // flip to check for those rather than a specific code.\n  }\n}\n\n/**\n * An error due to a \"compile-time\" check of the query\n * failing.\n */\nexport class QueryCheckError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus?: number) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, QueryCheckError);\n    }\n    this.name = \"QueryCheckError\";\n  }\n}\n\n/**\n * An error due to an invalid request to Fauna. Either the request body was not\n * valid JSON or did not conform to the API specification\n */\nexport class InvalidRequestError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus?: number) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, InvalidRequestError);\n    }\n    this.name = \"InvalidRequestError\";\n  }\n}\n\n/**\n * A runtime error due to failing schema constraints.\n */\nexport class ConstraintFailureError extends ServiceError {\n  /**\n   * The list of constraints that failed.\n   */\n  readonly constraint_failures: Array<ConstraintFailure>;\n\n  constructor(\n    failure: QueryFailure & {\n      error: { constraint_failures: Array<ConstraintFailure> };\n    },\n    httpStatus?: number,\n  ) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, QueryCheckError);\n    }\n    this.name = \"ConstraintFailureError\";\n    this.constraint_failures = failure.error.constraint_failures;\n  }\n}\n\n/**\n * An error due to calling the FQL `abort` function.\n */\nexport class AbortError extends ServiceError {\n  /**\n   * The user provided value passed to the originating `abort()` call.\n   * Present only when the query encountered an `abort()` call, which is denoted\n   * by the error code `\"abort\"`\n   */\n  readonly abort: QueryValue;\n\n  constructor(\n    failure: QueryFailure & { error: { abort: QueryValue } },\n    httpStatus?: number,\n  ) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, QueryCheckError);\n    }\n    this.name = \"AbortError\";\n    this.abort = failure.error.abort;\n  }\n}\n\n/**\n * AuthenticationError indicates invalid credentials were\n * used.\n */\nexport class AuthenticationError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus?: number) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AuthenticationError);\n    }\n    this.name = \"AuthenticationError\";\n  }\n}\n\n/**\n * AuthorizationError indicates the credentials used do not have\n * permission to perform the requested action.\n */\nexport class AuthorizationError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus?: number) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AuthorizationError);\n    }\n    this.name = \"AuthorizationError\";\n  }\n}\n\n/**\n * An error due to a contended transaction.\n */\nexport class ContendedTransactionError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus?: number) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, InvalidRequestError);\n    }\n    this.name = \"ContendedTransactionError\";\n  }\n}\n\n/**\n * ThrottlingError indicates some capacity limit was exceeded\n * and thus the request could not be served.\n */\nexport class ThrottlingError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus?: number) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ThrottlingError);\n    }\n    this.name = \"ThrottlingError\";\n  }\n}\n\n/**\n * A failure due to the query timeout being exceeded.\n *\n * This error can have one of two sources:\n *     1. Fauna is behaving expectedly, but the query timeout provided was too\n *        aggressive and lower than the query's expected processing time.\n *     2. Fauna was not available to service the request before the timeout was\n *        reached.\n *\n * In either case, consider increasing the `query_timeout_ms` configuration for\n * your client.\n */\nexport class QueryTimeoutError extends ServiceError {\n  /**\n   * Statistics regarding the query.\n   *\n   * TODO: Deprecate this `stats` field. All `ServiceError`s already provide\n   * access to stats through `queryInfo.stats`\n   */\n  readonly stats?: QueryStats;\n\n  constructor(failure: QueryFailure, httpStatus?: number) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, QueryTimeoutError);\n    }\n    this.name = \"QueryTimeoutError\";\n    this.stats = failure.stats;\n  }\n}\n\n/**\n * ServiceInternalError indicates Fauna failed unexpectedly.\n */\nexport class ServiceInternalError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus?: number) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ServiceInternalError);\n    }\n    this.name = \"ServiceInternalError\";\n  }\n}\n\n/**\n * An error representing a failure internal to the client, itself.\n * This indicates Fauna was never called - the client failed internally\n * prior to sending the request.\n */\nexport class ClientError extends FaunaError {\n  constructor(message: string, options?: { cause: any }) {\n    super(message, options);\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ClientError);\n    }\n    this.name = \"ClientError\";\n  }\n}\n\n/**\n * An error thrown if you try to call the client after it has been closed.\n */\nexport class ClientClosedError extends FaunaError {\n  constructor(message: string, options?: { cause: any }) {\n    super(message, options);\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ClientClosedError);\n    }\n    this.name = \"ClientClosedError\";\n  }\n}\n\n/**\n * An error representing a failure due to the network.\n * This indicates Fauna was never reached.\n */\nexport class NetworkError extends FaunaError {\n  constructor(message: string, options: { cause: any }) {\n    super(message, options);\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, NetworkError);\n    }\n    this.name = \"NetworkError\";\n  }\n}\n\n/**\n * An error representing a HTTP failure - but one not directly\n * emitted by Fauna.\n */\nexport class ProtocolError extends FaunaError {\n  /**\n   * The HTTP Status Code of the error.\n   */\n  readonly httpStatus: number;\n\n  constructor(error: { message: string; httpStatus: number }) {\n    super(error.message);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ProtocolError);\n    }\n\n    this.name = \"ProtocolError\";\n    this.httpStatus = error.httpStatus;\n  }\n}\n\nexport const getServiceError = (\n  failure: QueryFailure,\n  httpStatus?: number,\n): ServiceError => {\n  const failureCode = failure.error.code;\n\n  switch (failureCode) {\n    case \"invalid_query\":\n      return new QueryCheckError(failure, httpStatus);\n\n    case \"invalid_request\":\n      return new InvalidRequestError(failure, httpStatus);\n\n    case \"abort\":\n      if (failure.error.abort !== undefined) {\n        return new AbortError(\n          failure as QueryFailure & { error: { abort: QueryValue } },\n          httpStatus,\n        );\n      }\n      break;\n\n    case \"constraint_failure\":\n      if (failure.error.constraint_failures !== undefined) {\n        return new ConstraintFailureError(\n          failure as QueryFailure & {\n            error: { constraint_failures: Array<ConstraintFailure> };\n          },\n          httpStatus,\n        );\n      }\n      break;\n\n    case \"unauthorized\":\n      return new AuthenticationError(failure, httpStatus);\n\n    case \"forbidden\":\n      return new AuthorizationError(failure, httpStatus);\n\n    case \"contended_transaction\":\n      return new ContendedTransactionError(failure, httpStatus);\n\n    case \"limit_exceeded\":\n      return new ThrottlingError(failure, httpStatus);\n\n    case \"time_out\":\n      return new QueryTimeoutError(failure, httpStatus);\n\n    case \"internal_error\":\n      return new ServiceInternalError(failure, httpStatus);\n  }\n\n  return new QueryRuntimeError(failure, httpStatus);\n};\n", "/**\n * Readonly object representing the paths of the Fauna API to be used\n * with HTTP clients.\n */\nexport const FaunaAPIPaths = {\n  QUERY: \"/query/1\",\n  STREAM: \"/stream/1\",\n  EVENT_FEED: \"/feed/1\",\n} as const;\n\nexport type SupportedFaunaAPIPaths =\n  (typeof FaunaAPIPaths)[keyof typeof FaunaAPIPaths];\n", "/** following reference needed to include types for experimental fetch API in Node */\n/// <reference lib=\"dom\" />\n\nimport { getServiceError, NetworkError } from \"../errors\";\nimport { QueryFailure, QueryRequest } from \"../wire-protocol\";\nimport { FaunaAPIPaths } from \"./paths\";\nimport {\n  HTTPClient,\n  HTTPClientOptions,\n  HTTPRequest,\n  HTTPResponse,\n  HTTPStreamRequest,\n  HTTPStreamClient,\n  StreamAdapter,\n} from \"./http-client\";\n\n/**\n * An implementation for {@link HTTPClient} that uses the native fetch API\n */\nexport class FetchClient implements HTTPClient, HTTPStreamClient {\n  #baseUrl: string;\n  #defaultRequestPath = FaunaAPIPaths.QUERY;\n  #defaultStreamPath = FaunaAPIPaths.STREAM;\n  #keepalive: boolean;\n\n  constructor({ url, fetch_keepalive }: HTTPClientOptions) {\n    this.#baseUrl = url;\n    this.#keepalive = fetch_keepalive;\n  }\n\n  #resolveURL(path: string): string {\n    return new URL(path, this.#baseUrl).toString();\n  }\n\n  /** {@inheritDoc HTTPClient.request} */\n  async request<T = QueryRequest>({\n    data,\n    headers: requestHeaders,\n    method,\n    client_timeout_ms,\n    path = this.#defaultRequestPath,\n  }: HTTPRequest<T>): Promise<HTTPResponse> {\n    const signal =\n      AbortSignal.timeout === undefined\n        ? (() => {\n            const controller = new AbortController();\n            const signal = controller.signal;\n            setTimeout(() => controller.abort(), client_timeout_ms);\n            return signal;\n          })()\n        : AbortSignal.timeout(client_timeout_ms);\n\n    const response = await fetch(this.#resolveURL(path), {\n      method,\n      headers: { ...requestHeaders, \"Content-Type\": \"application/json\" },\n      body: JSON.stringify(data),\n      signal,\n      keepalive: this.#keepalive,\n    }).catch((error) => {\n      throw new NetworkError(\"The network connection encountered a problem.\", {\n        cause: error,\n      });\n    });\n\n    const status = response.status;\n\n    const responseHeaders: Record<string, string> = {};\n    response.headers.forEach((value, key) => (responseHeaders[key] = value));\n\n    const body = await response.text();\n\n    return {\n      status,\n      body,\n      headers: responseHeaders,\n    };\n  }\n\n  /** {@inheritDoc HTTPStreamClient.stream} */\n  stream({\n    data,\n    headers: requestHeaders,\n    method,\n    path = this.#defaultStreamPath,\n  }: HTTPStreamRequest): StreamAdapter {\n    const request = new Request(this.#resolveURL(path), {\n      method,\n      headers: { ...requestHeaders, \"Content-Type\": \"application/json\" },\n      body: JSON.stringify(data),\n      keepalive: this.#keepalive,\n    });\n\n    const abortController = new AbortController();\n\n    const options = {\n      signal: abortController.signal,\n    };\n\n    async function* reader() {\n      const response = await fetch(request, options).catch((error) => {\n        throw new NetworkError(\n          \"The network connection encountered a problem.\",\n          {\n            cause: error,\n          },\n        );\n      });\n      const status = response.status;\n      if (!(status >= 200 && status < 400)) {\n        const failure: QueryFailure = await response.json();\n        throw getServiceError(failure, status);\n      }\n\n      const body = response.body;\n      if (!body) {\n        throw new Error(\"Response body is undefined.\");\n      }\n      const reader = body.getReader();\n\n      try {\n        for await (const line of readLines(reader)) {\n          yield line;\n        }\n      } catch (error) {\n        throw new NetworkError(\n          \"The network connection encountered a problem while streaming events.\",\n          { cause: error },\n        );\n      }\n    }\n\n    return {\n      read: reader(),\n      close: () => {\n        abortController.abort(\"Stream closed by the client.\");\n      },\n    };\n  }\n\n  /** {@inheritDoc HTTPClient.close} */\n  close() {\n    // no actions at this time\n  }\n}\n\n/**\n * Get individual lines from the stream\n *\n * The stream may be broken into arbitrary chunks, but the events are delimited by a newline character.\n *\n * @param reader - The stream reader\n */\nasync function* readLines(reader: ReadableStreamDefaultReader<Uint8Array>) {\n  const textDecoder = new TextDecoder();\n  let partOfLine = \"\";\n  for await (const chunk of readChunks(reader)) {\n    const chunkText = textDecoder.decode(chunk);\n    const chunkLines = (partOfLine + chunkText).split(\"\\n\");\n\n    // Yield all complete lines\n    for (let i = 0; i < chunkLines.length - 1; i++) {\n      yield chunkLines[i].trim();\n    }\n\n    // Store the partial line\n    partOfLine = chunkLines[chunkLines.length - 1];\n  }\n\n  // Yield the remaining partial line if any\n  if (partOfLine.trim() !== \"\") {\n    yield partOfLine;\n  }\n}\n\nasync function* readChunks(reader: ReadableStreamDefaultReader<Uint8Array>) {\n  let done = false;\n  do {\n    const readResult = await reader.read();\n    if (readResult.value !== undefined) {\n      yield readResult.value;\n    }\n    done = readResult.done;\n  } while (!done);\n}\n", "let http2: any;\ntry {\n  http2 = require(\"node:http2\");\n} catch (_) {\n  http2 = undefined;\n}\nimport {\n  HTTPClient,\n  HTTPClientOptions,\n  HTTPRequest,\n  HTTPResponse,\n  HTTPStreamClient,\n  HTTPStreamRequest,\n  StreamAdapter,\n} from \"./http-client\";\nimport { NetworkError, getServiceError } from \"../errors\";\nimport { QueryFailure, QueryRequest } from \"../wire-protocol\";\nimport { FaunaAPIPaths } from \"./paths\";\n\n// alias http2 types\ntype ClientHttp2Session = any;\ntype ClientHttp2Stream = any;\ntype IncomingHttpHeaders = any;\ntype IncomingHttpStatusHeader = any;\ntype OutgoingHttpHeaders = any;\n\n/**\n * An implementation for {@link HTTPClient} that uses the node http package\n */\nexport class NodeHTTP2Client implements HTTPClient, HTTPStreamClient {\n  static #clients: Map<string, NodeHTTP2Client> = new Map();\n\n  #http2_session_idle_ms: number;\n  #http2_max_streams: number;\n  #url: string;\n  #numberOfUsers = 0;\n  #session: ClientHttp2Session | null;\n\n  #defaultRequestPath = FaunaAPIPaths.QUERY;\n  #defaultStreamPath = FaunaAPIPaths.STREAM;\n\n  private constructor({\n    http2_session_idle_ms,\n    url,\n    http2_max_streams,\n  }: HTTPClientOptions) {\n    if (http2 === undefined) {\n      throw new Error(\"Your platform does not support Node's http2 library\");\n    }\n\n    this.#http2_session_idle_ms = http2_session_idle_ms;\n    this.#http2_max_streams = http2_max_streams;\n    this.#url = url;\n    this.#session = null;\n  }\n\n  /**\n   * Gets a {@link NodeHTTP2Client} matching the {@link HTTPClientOptions}\n   * @param httpClientOptions - the {@link HTTPClientOptions}\n   * @returns a {@link NodeHTTP2Client} matching the {@link HTTPClientOptions}\n   */\n  static getClient(httpClientOptions: HTTPClientOptions): NodeHTTP2Client {\n    const clientKey = NodeHTTP2Client.#getClientKey(httpClientOptions);\n    if (!NodeHTTP2Client.#clients.has(clientKey)) {\n      NodeHTTP2Client.#clients.set(\n        clientKey,\n        new NodeHTTP2Client(httpClientOptions),\n      );\n    }\n    // we know that we have a client here\n    const client = NodeHTTP2Client.#clients.get(clientKey) as NodeHTTP2Client;\n    client.#numberOfUsers++;\n    return client;\n  }\n\n  static #getClientKey({ http2_session_idle_ms, url }: HTTPClientOptions) {\n    return `${url}|${http2_session_idle_ms}`;\n  }\n\n  /** {@inheritDoc HTTPClient.request} */\n  async request<T = QueryRequest>(req: HTTPRequest<T>): Promise<HTTPResponse> {\n    let retryCount = 0;\n    let memoizedError: any;\n    do {\n      try {\n        return await this.#doRequest(req);\n      } catch (error: any) {\n        // see https://github.com/nodejs/node/pull/42190/files\n        // and https://github.com/nodejs/help/issues/2105\n        //\n        // TLDR; In Node, there is a race condition between handling\n        // GOAWAY and submitting requests - that can cause\n        // clients that safely handle go away to submit\n        // requests after a GOAWAY was received anyway.\n        //\n        // technical explanation: node HTTP2 request gets put\n        // on event queue before it is actually executed. In the iterim,\n        // a GOAWAY can come and cause the request to fail\n        // with a GOAWAY.\n        if (error?.code !== \"ERR_HTTP2_GOAWAY_SESSION\") {\n          throw new NetworkError(\n            \"The network connection encountered a problem.\",\n            {\n              cause: error,\n            },\n          );\n        }\n        memoizedError = error;\n        retryCount++;\n      }\n    } while (retryCount < 3);\n    throw new NetworkError(\"The network connection encountered a problem.\", {\n      cause: memoizedError,\n    });\n  }\n\n  /** {@inheritDoc HTTPStreamClient.stream} */\n  stream(req: HTTPStreamRequest): StreamAdapter {\n    return this.#doStream(req);\n  }\n\n  /** {@inheritDoc HTTPClient.close} */\n  close() {\n    // defend against redundant close calls\n    if (this.isClosed()) {\n      return;\n    }\n    this.#numberOfUsers--;\n    if (this.#numberOfUsers === 0 && this.#session && !this.#session.closed) {\n      this.#session.close();\n    }\n  }\n\n  /**\n   * @returns true if this client has been closed, false otherwise.\n   */\n  isClosed(): boolean {\n    return this.#numberOfUsers === 0;\n  }\n\n  #closeForAll() {\n    this.#numberOfUsers = 0;\n    if (this.#session && !this.#session.closed) {\n      this.#session.close();\n    }\n  }\n\n  #connect() {\n    // create the session if it does not exist or is closed\n    if (!this.#session || this.#session.closed || this.#session.destroyed) {\n      const newSession: ClientHttp2Session = http2\n        .connect(this.#url, {\n          peerMaxConcurrentStreams: this.#http2_max_streams,\n        })\n        .once(\"error\", () => this.#closeForAll())\n        .once(\"goaway\", () => this.#closeForAll());\n\n      newSession.setTimeout(this.#http2_session_idle_ms, () => {\n        this.#closeForAll();\n      });\n\n      this.#session = newSession;\n    }\n    return this.#session;\n  }\n\n  #doRequest<T = QueryRequest>({\n    client_timeout_ms,\n    data: requestData,\n    headers: requestHeaders,\n    method,\n    path = this.#defaultRequestPath,\n  }: HTTPRequest<T>): Promise<HTTPResponse> {\n    return new Promise<HTTPResponse>((resolvePromise, rejectPromise) => {\n      let req: ClientHttp2Stream;\n      const onResponse = (\n        http2ResponseHeaders: IncomingHttpHeaders & IncomingHttpStatusHeader,\n      ) => {\n        const status = Number(\n          http2ResponseHeaders[http2.constants.HTTP2_HEADER_STATUS],\n        );\n        let responseData = \"\";\n\n        // append response data to the data string every time we receive new\n        // data chunks in the response\n        req.on(\"data\", (chunk: string) => {\n          responseData += chunk;\n        });\n\n        // Once the response is finished, resolve the promise\n        req.on(\"end\", () => {\n          resolvePromise({\n            status,\n            body: responseData,\n            headers: http2ResponseHeaders,\n          });\n        });\n      };\n\n      try {\n        const httpRequestHeaders: OutgoingHttpHeaders = {\n          ...requestHeaders,\n          [http2.constants.HTTP2_HEADER_PATH]: path,\n          [http2.constants.HTTP2_HEADER_METHOD]: method,\n        };\n\n        const session = this.#connect();\n        req = session\n          .request(httpRequestHeaders)\n          .setEncoding(\"utf8\")\n          .on(\"error\", (error: any) => {\n            rejectPromise(error);\n          })\n          .on(\"response\", onResponse);\n\n        req.write(JSON.stringify(requestData), \"utf8\");\n\n        // req.setTimeout must be called before req.end()\n        req.setTimeout(client_timeout_ms, () => {\n          req.destroy(new Error(`Client timeout`));\n        });\n\n        req.end();\n      } catch (error) {\n        rejectPromise(error);\n      }\n    });\n  }\n\n  /** {@inheritDoc HTTPStreamClient.stream} */\n  #doStream({\n    data: requestData,\n    headers: requestHeaders,\n    method,\n    path = this.#defaultStreamPath,\n  }: HTTPStreamRequest): StreamAdapter {\n    let resolveChunk: (chunk: string[]) => void;\n    let rejectChunk: (reason: any) => void;\n\n    const setChunkPromise = () =>\n      new Promise<string[]>((res, rej) => {\n        resolveChunk = res;\n        rejectChunk = rej;\n      });\n\n    let chunkPromise = setChunkPromise();\n\n    let req: ClientHttp2Stream;\n    const onResponse = (\n      http2ResponseHeaders: IncomingHttpHeaders & IncomingHttpStatusHeader,\n    ) => {\n      const status = Number(\n        http2ResponseHeaders[http2.constants.HTTP2_HEADER_STATUS],\n      );\n      if (!(status >= 200 && status < 400)) {\n        // Get the error body and then throw an error\n        let responseData = \"\";\n\n        // append response data to the data string every time we receive new\n        // data chunks in the response\n        req.on(\"data\", (chunk: string) => {\n          responseData += chunk;\n        });\n\n        // Once the response is finished, resolve the promise\n        req.on(\"end\", () => {\n          try {\n            const failure: QueryFailure = JSON.parse(responseData);\n            rejectChunk(getServiceError(failure, status));\n          } catch (error) {\n            rejectChunk(\n              new NetworkError(\"Could not process query failure.\", {\n                cause: error,\n              }),\n            );\n          }\n        });\n      } else {\n        let partOfLine = \"\";\n\n        // append response data to the data string every time we receive new\n        // data chunks in the response\n        req.on(\"data\", (chunk: string) => {\n          const chunkLines = (partOfLine + chunk).split(\"\\n\");\n\n          // Yield all complete lines\n          resolveChunk(chunkLines.map((s) => s.trim()).slice(0, -1));\n          chunkPromise = setChunkPromise();\n\n          // Store the partial line\n          partOfLine = chunkLines[chunkLines.length - 1];\n        });\n\n        // Once the response is finished, resolve the promise\n        req.on(\"end\", () => {\n          resolveChunk([partOfLine]);\n        });\n      }\n    };\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n\n    async function* reader(): AsyncGenerator<string> {\n      const httpRequestHeaders: OutgoingHttpHeaders = {\n        ...requestHeaders,\n        [http2.constants.HTTP2_HEADER_PATH]: path,\n        [http2.constants.HTTP2_HEADER_METHOD]: method,\n      };\n\n      const session = self.#connect();\n      req = session\n        .request(httpRequestHeaders)\n        .setEncoding(\"utf8\")\n        .on(\"error\", (error: any) => {\n          rejectChunk(error);\n        })\n        .on(\"response\", onResponse);\n\n      const body = JSON.stringify(requestData);\n\n      req.write(body, \"utf8\");\n\n      req.end();\n\n      while (true) {\n        const chunks = await chunkPromise;\n        for (const chunk of chunks) {\n          yield chunk;\n        }\n      }\n    }\n\n    return {\n      read: reader(),\n      close: () => {\n        if (req) {\n          req.close();\n        }\n      },\n    };\n  }\n}\n", "import { FetchClient } from \"./fetch-client\";\nimport {\n  HTTPClient,\n  HTTPClientOptions,\n  HTTPResponse,\n  HTTPStreamClient,\n} from \"./http-client\";\nimport { NodeHTTP2Client } from \"./node-http2-client\";\n\nexport * from \"./paths\";\nexport * from \"./fetch-client\";\nexport * from \"./http-client\";\nexport * from \"./node-http2-client\";\n\nexport const getDefaultHTTPClient = (\n  options: HTTPClientOptions,\n): HTTPClient & HTTPStreamClient =>\n  nodeHttp2IsSupported()\n    ? NodeHTTP2Client.getClient(options)\n    : new FetchClient(options);\n\nexport const isHTTPResponse = (res: any): res is HTTPResponse =>\n  res instanceof Object && \"body\" in res && \"headers\" in res && \"status\" in res;\n\nexport const isStreamClient = (\n  client: Partial<HTTPStreamClient>,\n): client is HTTPStreamClient => {\n  return \"stream\" in client && typeof client.stream === \"function\";\n};\n\nexport const nodeHttp2IsSupported = () => {\n  if (\n    typeof process !== \"undefined\" &&\n    process &&\n    process.release?.name === \"node\"\n  ) {\n    try {\n      require(\"node:http2\");\n      return true;\n    } catch (_) {\n      return false;\n    }\n  }\n  return false;\n};\n", "import base64 from \"base64-js\";\n\nimport { ClientError } from \"./errors\";\nimport {\n  DateStub,\n  Document,\n  DocumentReference,\n  Module,\n  NamedDocument,\n  NamedDocumentReference,\n  TimeStub,\n  Page,\n  NullDocument,\n  EmbeddedSet,\n  StreamToken,\n} from \"./values\";\nimport {\n  QueryValue,\n  QueryInterpolation,\n  ObjectFragment,\n  ArrayFragment,\n  FQLFragment,\n  ValueFragment,\n  TaggedType,\n  TaggedLong,\n  TaggedInt,\n  TaggedDouble,\n  TaggedObject,\n  EncodedObject,\n  TaggedTime,\n  TaggedDate,\n  TaggedMod,\n  TaggedRef,\n  TaggedBytes,\n} from \"./wire-protocol\";\nimport { Query, QueryArgument, QueryArgumentObject } from \"./query-builder\";\n\nexport interface DecodeOptions {\n  long_type: \"number\" | \"bigint\";\n}\n\n/**\n * TaggedType provides the encoding/decoding of the Fauna Tagged Type formatting\n */\nexport class TaggedTypeFormat {\n  /**\n   * Encode the value to the Tagged Type format for Fauna\n   *\n   * @param input - value that will be encoded\n   * @returns Map of result\n   */\n  static encode(input: QueryArgument): TaggedType {\n    return encode(input);\n  }\n\n  /**\n   * Encode the value to a QueryInterpolation to send to Fauna\n   *\n   * @param input - value that will be encoded\n   * @returns Map of result\n   */\n  static encodeInterpolation(input: QueryArgument): QueryInterpolation {\n    return encodeInterpolation(input);\n  }\n\n  /**\n   * Decode the JSON string result from Fauna to remove Tagged Type formatting.\n   *\n   * @param input - JSON string result from Fauna\n   * @returns object of result of FQL query\n   */\n  static decode(input: string, decodeOptions: DecodeOptions): any {\n    return JSON.parse(input, (_, value: any) => {\n      if (value == null) return null;\n      if (value[\"@mod\"]) {\n        return new Module(value[\"@mod\"]);\n      } else if (value[\"@doc\"]) {\n        // WIP: The string-based ref is being removed from the API\n        if (typeof value[\"@doc\"] === \"string\") {\n          const [modName, id] = value[\"@doc\"].split(\":\");\n          return new DocumentReference({ coll: modName, id: id });\n        }\n        // if not a docref string, then it is an object.\n        const obj = value[\"@doc\"];\n        if (obj.id) {\n          return new Document(obj);\n        } else {\n          return new NamedDocument(obj);\n        }\n      } else if (value[\"@ref\"]) {\n        const obj = value[\"@ref\"];\n        let ref: DocumentReference | NamedDocumentReference;\n        if (obj.id) {\n          ref = new DocumentReference(obj);\n        } else {\n          ref = new NamedDocumentReference(obj);\n        }\n        if (\"exists\" in obj && obj.exists === false) {\n          return new NullDocument(ref, obj.cause);\n        }\n        return ref;\n      } else if (value[\"@set\"]) {\n        if (typeof value[\"@set\"] === \"string\") {\n          return new EmbeddedSet(value[\"@set\"]);\n        }\n        return new Page(value[\"@set\"]);\n      } else if (value[\"@int\"]) {\n        return Number(value[\"@int\"]);\n      } else if (value[\"@long\"]) {\n        const bigInt = BigInt(value[\"@long\"]);\n        if (decodeOptions.long_type === \"number\") {\n          if (\n            bigInt > Number.MAX_SAFE_INTEGER ||\n            bigInt < Number.MIN_SAFE_INTEGER\n          ) {\n            console.warn(`Value is too large to be represented as a number. \\\nReturning as Number with loss of precision. Use long_type 'bigint' instead.`);\n          }\n          return Number(bigInt);\n        }\n        return bigInt;\n      } else if (value[\"@double\"]) {\n        return Number(value[\"@double\"]);\n      } else if (value[\"@date\"]) {\n        return DateStub.from(value[\"@date\"]);\n      } else if (value[\"@time\"]) {\n        return TimeStub.from(value[\"@time\"]);\n      } else if (value[\"@object\"]) {\n        return value[\"@object\"];\n      } else if (value[\"@stream\"]) {\n        return new StreamToken(value[\"@stream\"]);\n      } else if (value[\"@bytes\"]) {\n        return base64toBuffer(value[\"@bytes\"]);\n      }\n\n      return value;\n    });\n  }\n}\n\nexport const LONG_MIN = BigInt(\"-9223372036854775808\");\nexport const LONG_MAX = BigInt(\"9223372036854775807\");\nexport const INT_MIN = -(2 ** 31);\nexport const INT_MAX = 2 ** 31 - 1;\n\nconst encodeMap = {\n  bigint: (value: bigint): TaggedLong | TaggedInt => {\n    if (value < LONG_MIN || value > LONG_MAX) {\n      throw new RangeError(\n        \"BigInt value exceeds max magnitude for a 64-bit Fauna long. Use a 'number' to represent doubles beyond that limit.\",\n      );\n    }\n    if (value >= INT_MIN && value <= INT_MAX) {\n      return { \"@int\": value.toString() };\n    }\n    return {\n      \"@long\": value.toString(),\n    };\n  },\n  number: (value: number): TaggedDouble | TaggedInt | TaggedLong => {\n    if (\n      value === Number.POSITIVE_INFINITY ||\n      value === Number.NEGATIVE_INFINITY\n    ) {\n      throw new RangeError(`Cannot convert ${value} to a Fauna type.`);\n    }\n\n    if (!Number.isInteger(value)) {\n      return { \"@double\": value.toString() };\n    } else {\n      if (value >= INT_MIN && value <= INT_MAX) {\n        return { \"@int\": value.toString() };\n      } else if (Number.isSafeInteger(value)) {\n        return {\n          \"@long\": value.toString(),\n        };\n      }\n      return { \"@double\": value.toString() };\n    }\n  },\n  string: (value: string): string => {\n    return value;\n  },\n  object: (input: QueryArgumentObject): TaggedObject | EncodedObject => {\n    let wrapped = false;\n    const _out: EncodedObject = {};\n\n    for (const k in input) {\n      if (k.startsWith(\"@\")) {\n        wrapped = true;\n      }\n      if (input[k] !== undefined) {\n        _out[k] = encode(input[k]);\n      }\n    }\n    return wrapped ? { \"@object\": _out } : _out;\n  },\n  array: (input: QueryArgument[]): TaggedType[] => input.map(encode),\n  date: (dateValue: Date): TaggedTime => ({\n    \"@time\": dateValue.toISOString(),\n  }),\n  faunadate: (value: DateStub): TaggedDate => ({ \"@date\": value.dateString }),\n  faunatime: (value: TimeStub): TaggedTime => ({ \"@time\": value.isoString }),\n  module: (value: Module): TaggedMod => ({ \"@mod\": value.name }),\n  documentReference: (value: DocumentReference): TaggedRef => ({\n    \"@ref\": { id: value.id, coll: { \"@mod\": value.coll.name } },\n  }),\n  document: (value: Document): TaggedRef => ({\n    \"@ref\": { id: value.id, coll: { \"@mod\": value.coll.name } },\n  }),\n  namedDocumentReference: (value: NamedDocumentReference): TaggedRef => ({\n    \"@ref\": { name: value.name, coll: { \"@mod\": value.coll.name } },\n  }),\n  namedDocument: (value: NamedDocument): TaggedRef => ({\n    \"@ref\": { name: value.name, coll: { \"@mod\": value.coll.name } },\n  }),\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  set: (value: Page<QueryValue> | EmbeddedSet) => {\n    throw new ClientError(\n      \"Page could not be encoded. Fauna does not accept encoded Set values, yet. Use Page.data and Page.after as arguments, instead.\",\n    );\n    // TODO: uncomment to encode Pages once core starts accepting `@set` tagged values\n    // if (value.data === undefined) {\n    //   // if a Page has no data, then it must still have an 'after' cursor\n    //   return { \"@set\": value.after };\n    // }\n    // return {\n    //   \"@set\": { data: encodeMap[\"array\"](value.data), after: value.after },\n    // };\n  },\n  // TODO: encode as a tagged value if provided as a query arg?\n  // streamToken: (value: StreamToken): TaggedStreamToken => ({ \"@stream\": value.token }),\n  streamToken: (value: StreamToken): string => value.token,\n  bytes: (value: ArrayBuffer | Uint8Array): TaggedBytes => ({\n    \"@bytes\": bufferToBase64(value),\n  }),\n};\n\nconst encode = (input: QueryArgument): TaggedType => {\n  switch (typeof input) {\n    case \"bigint\":\n      return encodeMap[\"bigint\"](input);\n    case \"string\":\n      return encodeMap[\"string\"](input);\n    case \"number\":\n      return encodeMap[\"number\"](input);\n    case \"boolean\":\n      return input;\n    case \"object\":\n      if (input == null) {\n        return null;\n      } else if (Array.isArray(input)) {\n        return encodeMap[\"array\"](input);\n      } else if (input instanceof Date) {\n        return encodeMap[\"date\"](input);\n      } else if (input instanceof DateStub) {\n        return encodeMap[\"faunadate\"](input);\n      } else if (input instanceof TimeStub) {\n        return encodeMap[\"faunatime\"](input);\n      } else if (input instanceof Module) {\n        return encodeMap[\"module\"](input);\n      } else if (input instanceof Document) {\n        // Document extends DocumentReference, so order is important here\n        return encodeMap[\"document\"](input);\n      } else if (input instanceof DocumentReference) {\n        return encodeMap[\"documentReference\"](input);\n      } else if (input instanceof NamedDocument) {\n        // NamedDocument extends NamedDocumentReference, so order is important here\n        return encodeMap[\"namedDocument\"](input);\n      } else if (input instanceof NamedDocumentReference) {\n        return encodeMap[\"namedDocumentReference\"](input);\n      } else if (input instanceof NullDocument) {\n        return encode(input.ref);\n      } else if (input instanceof Page) {\n        return encodeMap[\"set\"](input);\n      } else if (input instanceof EmbeddedSet) {\n        return encodeMap[\"set\"](input);\n      } else if (input instanceof StreamToken) {\n        return encodeMap[\"streamToken\"](input);\n      } else if (input instanceof Uint8Array || input instanceof ArrayBuffer) {\n        return encodeMap[\"bytes\"](input);\n      } else if (ArrayBuffer.isView(input)) {\n        throw new ClientError(\n          \"Error encoding TypedArray to Fauna Bytes. Convert your TypedArray to Uint8Array or ArrayBuffer before passing it to Fauna. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\",\n        );\n      } else if (input instanceof Query) {\n        throw new TypeError(\n          \"Cannot encode instance of type 'Query'. Try using TaggedTypeFormat.encodeInterpolation instead.\",\n        );\n      } else {\n        return encodeMap[\"object\"](input);\n      }\n    default:\n      // catch \"undefined\", \"symbol\", and \"function\"\n      throw new TypeError(\n        `Passing ${typeof input} as a QueryArgument is not supported`,\n      );\n  }\n  // anything here would be unreachable code\n};\n\nconst encodeInterpolation = (input: QueryArgument): QueryInterpolation => {\n  switch (typeof input) {\n    case \"bigint\":\n    case \"string\":\n    case \"number\":\n    case \"boolean\":\n      return encodeValueInterpolation(encode(input));\n    case \"object\":\n      if (\n        input == null ||\n        input instanceof Date ||\n        input instanceof DateStub ||\n        input instanceof TimeStub ||\n        input instanceof Module ||\n        input instanceof DocumentReference ||\n        input instanceof NamedDocumentReference ||\n        input instanceof Page ||\n        input instanceof EmbeddedSet ||\n        input instanceof StreamToken ||\n        input instanceof Uint8Array ||\n        input instanceof ArrayBuffer ||\n        ArrayBuffer.isView(input)\n      ) {\n        return encodeValueInterpolation(encode(input));\n      } else if (input instanceof NullDocument) {\n        return encodeInterpolation(input.ref);\n      } else if (input instanceof Query) {\n        return encodeQueryInterpolation(input);\n      } else if (Array.isArray(input)) {\n        return encodeArrayInterpolation(input);\n      } else {\n        return encodeObjectInterpolation(input);\n      }\n    default:\n      // catch \"undefined\", \"symbol\", and \"function\"\n      throw new TypeError(\n        `Passing ${typeof input} as a QueryArgument is not supported`,\n      );\n  }\n};\n\nconst encodeObjectInterpolation = (\n  input: QueryArgumentObject,\n): ObjectFragment => {\n  const _out: EncodedObject = {};\n\n  for (const k in input) {\n    if (input[k] !== undefined) {\n      _out[k] = encodeInterpolation(input[k]);\n    }\n  }\n  return { object: _out };\n};\n\nconst encodeArrayInterpolation = (\n  input: Array<QueryArgument>,\n): ArrayFragment => {\n  const encodedItems = input.map(encodeInterpolation);\n  return { array: encodedItems };\n};\n\nconst encodeQueryInterpolation = (value: Query): FQLFragment => value.encode();\n\nconst encodeValueInterpolation = (value: TaggedType): ValueFragment => ({\n  value,\n});\n\nfunction base64toBuffer(value: string): Uint8Array {\n  return base64.toByteArray(value);\n}\n\nfunction bufferToBase64(value: ArrayBuffer | Uint8Array): string {\n  const arr: Uint8Array =\n    value instanceof Uint8Array ? value : new Uint8Array(value);\n\n  return base64.fromByteArray(arr);\n}\n", "// Date and Time expressions\n\nconst yearpart = /(?:\\d{4}|[\\u2212-]\\d{4,}|\\+\\d{5,})/;\nconst monthpart = /(?:0[1-9]|1[0-2])/;\nconst daypart = /(?:0[1-9]|[12]\\d|3[01])/;\nconst hourpart = /(?:[01][0-9]|2[0-3])/;\nconst minsecpart = /(?:[0-5][0-9])/;\nconst decimalpart = /(?:\\.\\d+)/;\n\nconst datesplit = new RegExp(\n  `(${yearpart.source}-(${monthpart.source})-(${daypart.source}))`\n);\n\nconst timesplit = new RegExp(\n  `(${hourpart.source}:${minsecpart.source}:${minsecpart.source}${decimalpart.source}?)`\n);\n\nconst zonesplit = new RegExp(\n  `([zZ]|[+\\u2212-]${hourpart.source}(?::?${minsecpart.source}|:${minsecpart.source}:${minsecpart.source}))`\n);\n\n/**\n * Matches the subset of ISO8601 dates that Fauna can accept. Cannot include any\n * time part\n */\nexport const plaindate = new RegExp(`^${datesplit.source}$`);\n\n/**\n * Matches a valid ISO8601 date and can have anything trailing after.\n */\nexport const startsWithPlaindate = new RegExp(`^${datesplit.source}`);\n\n/**\n * Matches the subset of ISO8601 times that Fauna can accept.\n */\nexport const datetime = new RegExp(\n  `^${datesplit.source}T${timesplit.source}${zonesplit.source}$`\n);\n", "import { ClientError } from \"../errors\";\nimport * as PARSE from \"../regex\";\n\n/**\n * A wrapper around the Fauna `Time` type. It, represents a fixed point in time\n * without regard to calendar or location, e.g. July 20, 1969, at 20:17 UTC.\n * Convert to and from Javascript Date's with the {@link TimeStub.fromDate} and\n * {@link TimeStub.toDate} methods.\n * See remarks for possible precision loss when doing this. If precision loss is\n * a concern consider using a 3rd party datetime library such as luxon.\n *\n * @remarks The Javascript `Date` type most closely resembles a Fauna `Time`,\n * not a Fauna `Date`. However, Fauna stores `Time` values with nanosecond\n * precision, while Javascript `Date` values only have millisecond precision.\n * This TimeStub class preserves precision by storing the original string value\n * and should be used whenever possible to pass `Time` values back to Fauna.\n * Converting to a Javascript date before sending to Fauna could result in loss\n * of precision.\n *\n * @see {@link https://docs.fauna.com/fauna/current/reference/fql_reference/types#time}\n */\nexport class TimeStub {\n  readonly isoString: string;\n\n  /**\n   * @remarks constructor is private to enforce using factory functions\n   */\n  private constructor(isoString: string) {\n    this.isoString = isoString;\n  }\n\n  /**\n   * Creates a new {@link TimeStub} from an ISO date string\n   * @param isoString - An ISO date string.\n   * @returns A new {@link TimeStub}\n   * @throws TypeError if a string is not provided, or RangeError if item\n   * is not a valid date\n   */\n  static from(isoString: string): TimeStub {\n    if (typeof isoString !== \"string\") {\n      throw new TypeError(\n        `Expected string but received ${typeof isoString}: ${isoString}`\n      );\n    }\n    const matches = PARSE.datetime.exec(isoString);\n    if (matches === null) {\n      throw new RangeError(\n        `(regex) Expected an ISO date string but received '${isoString}'`\n      );\n    }\n    // There are some dates that match the regex but are invalid, such as Feb 31.\n    // Javascript does not parse all years that are valid in fauna, so let\n    // Fauna be the final check.\n\n    return new TimeStub(isoString);\n  }\n\n  /**\n   * Creates a new {@link TimeStub} from a Javascript `Date`\n   * @param date - A Javascript `Date`\n   * @returns A new {@link TimeStub}\n   */\n  static fromDate(date: Date): TimeStub {\n    return new TimeStub(date.toISOString());\n  }\n\n  /**\n   * Get a copy of the `TimeStub` converted to a Javascript `Date`. Does not\n   * mutate the existing `TimeStub` value.\n   * @returns A `Date`\n   */\n  toDate(): Date {\n    const date = new Date(this.isoString);\n    if (date.toString() === \"Invalid Date\") {\n      throw new RangeError(\n        \"Fauna Date could not be converted to Javascript Date\"\n      );\n    }\n    return date;\n  }\n\n  /**\n   * Override default string conversion\n   * @returns the string representation of a `TimeStub`\n   */\n  toString(): string {\n    return `TimeStub(\"${this.isoString}\")`;\n  }\n}\n\n/**\n * A wrapper aroud the Fauna `Date` type. It represents a calendar date that is\n * not associated with a particular time or time zone, e.g. August 24th, 2006.\n * Convert to and from Javascript Date's with the {@link DateStub.fromDate} and\n * {@link DateStub.toDate} methods. Javascript Dates are rendered in UTC time\n * before the date part is used.\n * See remarks for possible precision loss when doing this. If precision loss is\n * a concern consider using a 3rd party datetime library such as luxon.\n *\n * @remarks The Javascript `Date` type always has a time associated with it, but\n * Fauna's `Date` type does not. When converting from a Fauna `Date` to a\n * Javascript `Date`, we set time to 00:00:00 UTC. When converting a Javascript\n * `Date` or time string to Fauna `Date`, we convert to UTC first. Care should\n * be taken to specify the desired date, since Javascript `Date`s use local\n * timezone info by default.\n *\n * @see {@link https://docs.fauna.com/fauna/current/reference/fql_reference/types#date}\n */\nexport class DateStub {\n  readonly dateString: string;\n\n  /**\n   * @remarks constructor is private to enforce using factory functions\n   */\n  private constructor(dateString: string) {\n    this.dateString = dateString;\n  }\n\n  /**\n   * Creates a new {@link DateStub} from a date string\n   * @param dateString - A plain date string. The time is converted to UTC\n   * before saving the date.\n   * @returns A new {@link DateStub}\n   * @throws TypeError if a string is not provided, or RangeError if dateString\n   * is not a valid date\n   */\n  static from(dateString: string): DateStub {\n    if (typeof dateString !== \"string\") {\n      throw new TypeError(\n        `Expected string but received ${typeof dateString}: ${dateString}`\n      );\n    }\n    const matches = PARSE.plaindate.exec(dateString);\n    if (matches === null) {\n      throw new RangeError(\n        `Expected a plain date string but received '${dateString}'`\n      );\n    }\n    // There are some dates that match the regex but are invalid, such as Feb 31.\n    // Javascript does not parse all years that are valid in fauna, so let\n    // Fauna be the final check.\n\n    return new DateStub(matches[0]);\n  }\n\n  /**\n   * Creates a new {@link DateStub} from a Javascript `Date`\n   * @param date - A Javascript `Date`. The time is converted to UTC before\n   * saving the date.\n   * @returns A new {@link DateStub}\n   */\n  static fromDate(date: Date): DateStub {\n    const dateString = date.toISOString();\n    const matches = PARSE.startsWithPlaindate.exec(dateString);\n    if (matches === null) {\n      // Our regex should match any possible date that comes out of\n      // `Date.toISOString()`, so we will only get here if the regex is\n      // incorrect. This is a ClientError since it is our fault.\n      throw new ClientError(`Failed to parse date '${date}'`);\n    }\n    return new DateStub(matches[0]);\n  }\n\n  /**\n   * Get a copy of the `TimeStub` converted to a Javascript `Date`. Does not\n   * mutate the existing `TimeStub` value.\n   * @returns A `Date`\n   */\n  toDate(): Date {\n    const date = new Date(this.dateString + \"T00:00:00Z\");\n    if (date.toString() === \"Invalid Date\") {\n      throw new RangeError(\n        \"Fauna Date could not be converted to Javascript Date\"\n      );\n    }\n    return date;\n  }\n\n  /**\n   * Override default string conversion\n   * @returns the string representation of a `DateStub`\n   */\n  toString(): string {\n    return `DateStub(\"${this.dateString}\")`;\n  }\n}\n", "import { QueryValueObject } from \"../wire-protocol\";\nimport { TimeStub } from \"./date-time\";\n\n/**\n * A reference to a Document with an ID. The Document may or may not exist.\n * References to Keys, Tokens, and Documents in user-defined Collections are\n * modeled with a {@link DocumentReference}.\n *\n * The example below retrieves a document reference from a\n * hypothetical \"Users\" collection.\n *\n * @example\n * ```javascript\n *  const response = await client.query(fql`\n *    Users.byId(\"101\")\n *  `);\n *  const userDocumentReference = response.data;\n *\n *  const id = userDocumentReference.id;\n *  id === \"101\"; // returns true\n * ```\n *\n * @see {@link https://docs.fauna.com/fauna/current/reference/fql_reference/types#special}\n */\nexport class DocumentReference {\n  readonly coll: Module;\n  readonly id: string;\n\n  constructor({ coll, id }: { coll: Module | string; id: string }) {\n    this.id = id;\n\n    if (typeof coll === \"string\") {\n      this.coll = new Module(coll);\n    } else {\n      this.coll = coll;\n    }\n  }\n}\n\n/**\n * A materialized Document with an ID. Keys, Tokens and Documents in\n * user-defined Collections are modeled with a {@link Document}. All top level\n * Document fields are added to a {@link Document} instance, but types cannot be\n * provided. Cast the instance to a {@link DocumentT} to have typesafe access to\n * all top level fields.\n *\n * The example below retrieves a document from a\n * hypothetical \"Users\" collection.\n *\n * @example\n * ```javascript\n *  const response = await client.query(fql`\n *    Users.byId(\"101\")\n *  `);\n *  const userDocument = response.data;\n *\n *  const color = userDocument.color;\n * ```\n *\n * @remarks The {@link Document} class cannot be generic because classes cannot\n * extend generic type arguments.\n *\n * @see {@link https://docs.fauna.com/fauna/current/reference/fql_reference/types#special}\n */\nexport class Document extends DocumentReference {\n  readonly ts: TimeStub;\n  readonly ttl?: TimeStub;\n\n  constructor(obj: {\n    coll: Module | string;\n    id: string;\n    ts: TimeStub;\n    [key: string]: any;\n  }) {\n    const { coll, id, ts, ...rest } = obj;\n    super({ coll, id });\n    this.ts = ts;\n    Object.assign(this, rest);\n  }\n\n  toObject(): { coll: Module; id: string; ts: TimeStub; ttl?: TimeStub } {\n    return { ...this };\n  }\n}\n\n/**\n * A reference to a Document with a name. The Document may or may not exist.\n * References to specific AccessProviders, Collections, Databases, Functions, etc. are\n * modeled with a {@link NamedDocumentReference}.\n *\n * The example below retrieves a NamedDocumentReference for a hypothetical\n * \"Users\" collection.\n *\n * @example\n * ```javascript\n *  const response = await client.query(fql`\n *    Users.definition\n *  `);\n *  const namedDocumentReference = response.data;\n *\n *  const collectionName = namedDocumentReference.name;\n *  collectionName === \"Users\"; // returns true\n * ```\n *\n * @see {@link https://docs.fauna.com/fauna/current/reference/fql_reference/types#special}\n */\nexport class NamedDocumentReference {\n  readonly coll: Module;\n  readonly name: string;\n\n  constructor({ coll, name }: { coll: Module | string; name: string }) {\n    this.name = name;\n\n    if (typeof coll === \"string\") {\n      this.coll = new Module(coll);\n    } else {\n      this.coll = coll;\n    }\n  }\n}\n\n/**\n * A materialized Document with a name. Specific AccessProviders, Collections, Databases,\n * Functions, etc. that include user defined data are modeled with a {@link NamedDocument}.\n *\n * The example below retrieves a NamedDocument for a hypothetical\n * \"Users\" collection.\n *\n * @example\n * ```javascript\n *  const response = await client.query(fql`\n *    Users.definition\n *  `);\n *  const userCollectionNamedDocument = response.data;\n *\n *  const indexes = userCollectionNamedDocument.indexes;\n * ```\n *\n * @example\n * All of the named Documents can have optional, user-defined data. The generic\n * class lets you define the shape of that data in a typesafe way\n * ```typescript\n *  type CollectionMetadata = {\n *    metadata: string\n *  }\n *\n *  const response = await client.query<NamedDocument<CollectionMetadata>>(fql`\n *    Users.definition\n *  `);\n *  const userCollection = response.data;\n *\n *  const metadata = userCollection.data.metadata;\n * ```\n *\n * @see {@link https://docs.fauna.com/fauna/current/reference/fql_reference/types#special}\n */\nexport class NamedDocument<\n  T extends QueryValueObject = Record<string, never>,\n> extends NamedDocumentReference {\n  readonly ts: TimeStub;\n  readonly data: T;\n\n  constructor(obj: {\n    coll: Module | string;\n    name: string;\n    ts: TimeStub;\n    data?: T;\n  }) {\n    const { coll, name, ts, data, ...rest } = obj;\n    super({ coll, name });\n    this.ts = ts;\n    this.data = data || ({} as T);\n    Object.assign(this, rest);\n  }\n\n  toObject(): { coll: Module; name: string; ts: TimeStub; data: T } {\n    return { ...this } as { coll: Module; name: string; ts: TimeStub; data: T };\n  }\n}\n\n/**\n * A Fauna module, such as a Collection, Database, Function, Role, etc.\n * Every module is usable directly in your FQL code.\n *\n * The example below shows FQL code that gets all documents for a hypothetical\n * 'Users' collection by creating a Module for user and then calling .all().\n *\n * You can also create modules for databases, functions, roles and other\n * entities in your database.\n *\n * @example\n * ```javascript\n *  const response = await client.query(fql`\n *    ${new Module(\"Users\")}.all()\n *  `);\n *  const allUserDocuments = response.data;\n * ```\n *\n * @see {@link https://docs.fauna.com/fauna/current/reference/fql_reference/types#module}\n */\nexport class Module {\n  readonly name: string;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\n/**\n * A reference to a Document or Named Document that could not be read. The\n * Document may or may not exist in future queries. The cause field specifies\n * the reason the document could not be read, typically because the Document\n * does not exist or due to insufficient privileges.\n *\n * Some read operations, such as the `<Collection>.byId` method may return\n * either a Document or a NullDocument. This example shows how to handle such a\n * result with the driver\n *\n * @example\n * ```typescript\n *  const response = await client.query<Document | NullDocument>(fql`\n *    Users.byId(\"101\")\n *  `);\n *  const maybeUserDocument = response.data;\n *\n *  if (maybeUserDocument instanceof NullDocument) {\n *    // handle NullDocument case\n *    const cause = maybeUserDocument.cause\n *  } else {\n *    // handle Document case\n *    const color = maybeUserDocument.color;\n *  }\n * ```\n *\n * @see {@link https://docs.fauna.com/fauna/current/reference/fql_reference/types#nulldoc}\n */\nexport class NullDocument {\n  readonly ref: DocumentReference | NamedDocumentReference;\n  readonly cause: string;\n\n  constructor(ref: DocumentReference | NamedDocumentReference, cause: string) {\n    this.ref = ref;\n    this.cause = cause;\n  }\n}\n\n/**\n * A Document typed with a user-defined data type. Typescript users can cast\n * instances of {@link Document} to {@link DocumentT} to access user-defined fields with type safety.\n *\n * The example below creates a local type \"User\" that is applied to queries for documents in a\n * hypothetical \"Users\" collection.\n *\n * @example\n * ```typescript\n *  type User = {\n *    color: string\n *  }\n *\n *  const response = await client.query<DocumentT<User>>(fql`\n *    Users.byId(\"101\")\n *  `);\n *  const user = response.data;\n *\n *  const color = user.color;\n * ```\n *\n * @remarks The {@link Document} class cannot be generic because classes cannot\n * extend generic type arguments.\n */\nexport type DocumentT<T extends QueryValueObject> = Document & T;\n", "import { Client } from \"../client\";\nimport { Query, fql } from \"../query-builder\";\nimport { QueryOptions, QueryValue } from \"../wire-protocol\";\n\n/**\n * A materialized view of a Set.\n * @see {@link https://docs.fauna.com/fauna/current/reference/fql_reference/types#set}\n */\nexport class Page<T extends QueryValue> {\n  /** A materialized page of data */\n  readonly data: T[];\n  /**\n   * A pagination cursor, used to obtain additional information in the Set.\n   * If `after` is not provided, then `data` must be present and represents the\n   * last Page in the Set.\n   */\n  readonly after?: string;\n\n  constructor({ data, after }: { data: T[]; after?: string }) {\n    this.data = data;\n    this.after = after;\n  }\n}\n\n/**\n * A un-materialized Set. Typically received when a materialized Set contains\n * another set, the EmbeddedSet does not contain any data to avoid potential\n * issues such as self-reference and infinite recursion\n * @see {@link https://docs.fauna.com/fauna/current/reference/fql_reference/types#set}\n */\nexport class EmbeddedSet {\n  /**\n   * A pagination cursor, used to obtain additional information in the Set.\n   */\n  readonly after: string;\n\n  constructor(after: string) {\n    this.after = after;\n  }\n}\n\n/**\n * A class to provide an iterable API for fetching multiple pages of data, given\n * a Fauna Set\n */\nexport class SetIterator<T extends QueryValue>\n  implements AsyncGenerator<T[], void, unknown>\n{\n  readonly #generator: AsyncGenerator<T[], void, unknown>;\n\n  /**\n   * Constructs a new {@link SetIterator}.\n   *\n   * @remarks Though you can use {@link SetIterator} class directly, it is\n   * most common to create an instance through the {@link Client.paginate} `paginate`\n   * method.\n   *\n   * @typeParam T - The expected type of the items returned from Fauna on each\n   * iteration\n   * @param client - The {@link Client} that will be used to fetch new data on\n   * each iteration\n   * @param initial - An existing fauna Set ({@link Page} or\n   * {@link EmbeddedSet}) or function which returns a promise. If the Promise\n   * resolves to a {@link Page} or {@link EmbeddedSet} then the iterator will\n   * use the client to fetch additional pages of data.\n   * @param options - a {@link QueryOptions} to apply to the queries. Optional.\n   */\n  constructor(\n    client: Client,\n    initial: Page<T> | EmbeddedSet | (() => Promise<T | Page<T> | EmbeddedSet>),\n    options?: QueryOptions,\n  ) {\n    options = options ?? {};\n    if (initial instanceof Function) {\n      this.#generator = generateFromThunk(client, initial, options);\n    } else if (initial instanceof Page || initial instanceof EmbeddedSet) {\n      this.#generator = generatePages(client, initial, options);\n    } else {\n      throw new TypeError(\n        `Expected 'Page<T> | EmbeddedSet | (() => Promise<T | Page<T> | EmbeddedSet>)', but received ${JSON.stringify(\n          initial,\n        )}`,\n      );\n    }\n  }\n\n  /**\n   * Constructs a new {@link SetIterator} from an {@link Query}\n   *\n   * @internal Though you can use {@link SetIterator.fromQuery} directly, it is\n   * intended as a convenience for use in the {@link Client.paginate} method\n   */\n  static fromQuery<T extends QueryValue>(\n    client: Client,\n    query: Query,\n    options?: QueryOptions,\n  ): SetIterator<T> {\n    return new SetIterator<T>(\n      client,\n      async () => {\n        const response = await client.query<T | Page<T> | EmbeddedSet>(\n          query,\n          options,\n        );\n        return response.data;\n      },\n      options,\n    );\n  }\n\n  /**\n   * Constructs a new {@link SetIterator} from an {@link Page} or\n   * {@link EmbeddedSet}\n   *\n   * @internal Though you can use {@link SetIterator.fromPageable} directly, it\n   * is intended as a convenience for use in the {@link Client.paginate} method\n   */\n  static fromPageable<T extends QueryValue>(\n    client: Client,\n    pageable: Page<T> | EmbeddedSet,\n    options?: QueryOptions,\n  ): SetIterator<T> {\n    return new SetIterator<T>(client, pageable, options);\n  }\n\n  /**\n   * Constructs a new {@link FlattenedSetIterator} from the current instance\n   *\n   * @returns A new {@link FlattenedSetIterator} from the current instance\n   */\n  flatten(): FlattenedSetIterator<T> {\n    return new FlattenedSetIterator(this);\n  }\n\n  /** Implement\n   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncGenerator/next| AsyncGenerator.next}\n   * */\n  async next(): Promise<IteratorResult<T[], void>> {\n    return this.#generator.next();\n  }\n\n  /** Implement\n   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncGenerator/return| AsyncGenerator.return}\n   * */\n  async return(): Promise<IteratorResult<T[], void>> {\n    return this.#generator.return();\n  }\n\n  /** Implement\n   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncGenerator/throw| AsyncGenerator.throw}\n   * */\n  async throw(e: any): Promise<IteratorResult<T[], void>> {\n    return this.#generator.throw(e);\n  }\n\n  /** Implement\n   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncGenerator| AsyncGenerator}\n   * */\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n}\n\n/**\n * A class to provide an iterable API for fetching multiple pages of data, given\n * a Fauna Set. This class takes a {@link SetIterator} and flattens the results\n * to yield the items directly.\n */\nexport class FlattenedSetIterator<T extends QueryValue>\n  implements AsyncGenerator<T, void, unknown>\n{\n  readonly #generator: AsyncGenerator<T, void, unknown>;\n\n  /**\n   * Constructs a new {@link FlattenedSetIterator}.\n   *\n   * @remarks Though you can use {@link FlattenedSetIterator} class directly, it\n   * is most common to create an instance through the\n   * {@link SetIterator.flatten} method.\n   *\n   * @typeParam T - The expected type of the items returned from Fauna on each\n   * iteration\n   * @param setIterator - The {@link SetIterator}\n   */\n  constructor(setIterator: SetIterator<T>) {\n    this.#generator = generateItems(setIterator);\n  }\n\n  /** Implement\n   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncGenerator/next| AsyncGenerator.next}\n   * */\n  async next(): Promise<IteratorResult<T, void>> {\n    return this.#generator.next();\n  }\n\n  /** Implement\n   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncGenerator/return| AsyncGenerator.return}\n   * */\n  async return(): Promise<IteratorResult<T, void>> {\n    return this.#generator.return();\n  }\n\n  /** Implement\n   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncGenerator/throw| AsyncGenerator.throw}\n   * */\n  async throw(e: any): Promise<IteratorResult<T, void>> {\n    return this.#generator.throw(e);\n  }\n\n  /** Implement\n   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncGenerator| AsyncGenerator}\n   * */\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n}\n\n/**\n * Internal async generator function to use with {@link Page} and\n * {@link EmbeddedSet} values\n */\nasync function* generatePages<T extends QueryValue>(\n  client: Client,\n  initial: Page<T> | EmbeddedSet,\n  options: QueryOptions,\n): AsyncGenerator<T[], void, unknown> {\n  let currentPage = initial;\n\n  if (currentPage instanceof Page) {\n    yield currentPage.data;\n  }\n\n  while (currentPage.after) {\n    // cursor means there is more data to fetch\n    const query = fql`Set.paginate(${currentPage.after})`;\n    const response = await client.query<Page<T>>(query, options);\n    const nextPage = response.data;\n\n    currentPage = nextPage;\n    yield currentPage.data;\n  }\n}\n\n/**\n * Internal async generator function to use with a function that returns a\n * promise of data. If the promise resolves to a {@link Page} or\n * {@link EmbeddedSet} then continue iterating.\n */\nasync function* generateFromThunk<T extends QueryValue>(\n  client: Client,\n  thunk: () => Promise<T | Page<T> | EmbeddedSet>,\n  options: QueryOptions,\n): AsyncGenerator<T[], void, unknown> {\n  const result = await thunk();\n\n  if (result instanceof Page || result instanceof EmbeddedSet) {\n    for await (const page of generatePages(\n      client,\n      result as Page<T> | EmbeddedSet,\n      options,\n    )) {\n      yield page;\n    }\n    return;\n  }\n\n  yield [result];\n}\n\n/**\n * Internal async generator function that flattens a {@link SetIterator}\n */\nasync function* generateItems<T extends QueryValue>(\n  setIterator: SetIterator<T>,\n) {\n  for await (const page of setIterator) {\n    for (const item of page) {\n      yield item;\n    }\n  }\n}\n", "import {\n  FeedSuccess,\n  QueryValue,\n  StreamEventData,\n  QueryStats,\n} from \"../wire-protocol\";\nimport { getServiceError } from \"../errors\";\n\n/**\n * A token used to initiate a Fauna event source at a particular snapshot in time.\n *\n * The example below shows how to request an event token from Fauna and use it\n * to establish an event steam.\n *\n * @example\n * ```javascript\n *  const response = await client.query(fql`\n *    Messages.byRecipient(User.byId(\"1234\"))\n *  `);\n *  const eventSource = response.data;\n *\n *  const stream = client.stream(eventSource)\n *    .on(\"add\", (event) => console.log(\"New message\", event))\n *\n *  stream.start();\n * ```\n */\nexport interface EventSource {\n  readonly token: string;\n}\n\nexport function isEventSource(value: any): value is EventSource {\n  if (typeof value.token === \"string\") {\n    return true;\n  }\n\n  return false;\n}\n\nexport class StreamToken implements EventSource {\n  readonly token: string;\n\n  constructor(token: string) {\n    this.token = token;\n  }\n}\n\n/**\n * A class to represent a page of events from a Fauna stream.\n */\nexport class FeedPage<T extends QueryValue> {\n  readonly events: IterableIterator<StreamEventData<T>>;\n  readonly cursor: string;\n  readonly hasNext: boolean;\n  readonly stats?: QueryStats;\n\n  constructor({ events, cursor, has_next, stats }: FeedSuccess<T>) {\n    this.events = this.#toEventIterator(events);\n    this.cursor = cursor;\n    this.hasNext = has_next;\n    this.stats = stats;\n  }\n\n  *#toEventIterator(\n    events: FeedSuccess<T>[\"events\"],\n  ): IterableIterator<StreamEventData<T>> {\n    // A page of events may contain an error event. These won't be reported\n    // at a response level, so we need to check for them here. They are\n    // considered fatal. Pages end at the first error event.\n    for (const event of events) {\n      if (event.type === \"error\") {\n        throw getServiceError(event);\n      }\n\n      yield event;\n    }\n  }\n}\n", "import { TaggedTypeFormat } from \"./tagged-type\";\nimport type {\n  FQLFragment,\n  QueryValue,\n  QueryInterpolation,\n} from \"./wire-protocol\";\n\n/**\n * A QueryArgumentObject is a plain javascript object where each property is a\n * valid QueryArgument.\n */\nexport type QueryArgumentObject = {\n  [key: string]: QueryArgument;\n};\n\n/**\n * A QueryArgument represents all possible values that can be encoded and passed\n * to Fauna as a query argument.\n *\n * The {@link fql} tagged template function requires all arguments to be of type\n * QueryArgument.\n */\nexport type QueryArgument =\n  | QueryValue\n  | Query<any>\n  | Date\n  | ArrayBuffer\n  | Uint8Array\n  | Array<QueryArgument>\n  | QueryArgumentObject;\n\n/**\n * Creates a new Query. Accepts template literal inputs.\n * @typeParam T - The expected type of the response from Fauna when evaluated.\n * @param queryFragments - An array that constitutes\n *   the strings that are the basis of the query.\n * @param queryArgs - an Array\\<QueryValue | Query\\> that\n *   constitute the arguments to inject between the queryFragments.\n * @throws Error - if you call this method directly (not using template\n *   literals) and pass invalid construction parameters\n * @example\n * ```typescript\n *  const str = \"baz\";\n *  const num = 17;\n *  const innerQuery = fql`${num} + 3)`;\n *  const queryRequestBuilder = fql`${str}.length == ${innerQuery}`;\n * ```\n */\nexport function fql<T extends QueryValue = any>(\n  queryFragments: ReadonlyArray<string>,\n  ...queryArgs: QueryArgument[]\n): Query<T> {\n  return new Query<T>(queryFragments, ...queryArgs);\n}\n\n/**\n * Internal class.\n * A builder for composing queries using the {@link fql} tagged template\n * function\n * @typeParam T - The expected type of the response from Fauna when evaluated.\n *   T can be used to infer the type of the response type from {@link Client}\n *   methods.\n */\nexport class Query<T extends QueryValue = any> {\n  readonly #queryFragments: ReadonlyArray<string>;\n  readonly #interpolatedArgs: QueryArgument[];\n  /**\n   * A phantom field to enforce the type of the Query.\n   * @internal\n   *\n   * We need to provide an actual property of type `T` for Typescript to\n   * actually enforce it.\n   *\n   * \"Because TypeScript is a structural type system, type parameters only\n   * affect the resulting type when consumed as part of the type of a member.\"\n   *\n   * @see {@link https://www.typescriptlang.org/docs/handbook/type-compatibility.html#generics}\n   */\n  readonly #__phantom: T;\n\n  constructor(\n    queryFragments: ReadonlyArray<string>,\n    ...queryArgs: QueryArgument[]\n  ) {\n    if (\n      queryFragments.length === 0 ||\n      queryFragments.length !== queryArgs.length + 1\n    ) {\n      throw new Error(\"invalid query constructed\");\n    }\n    this.#queryFragments = queryFragments;\n    this.#interpolatedArgs = queryArgs;\n\n    // HACK: We have to construct the phantom field, but we don't have any value for it.\n    this.#__phantom = undefined as unknown as T;\n  }\n\n  /**\n   * Converts this Query to an {@link FQLFragment} you can send\n   * to Fauna.\n   * @returns a {@link FQLFragment}.\n   * @example\n   * ```typescript\n   *  const num = 8;\n   *  const queryBuilder = fql`'foo'.length == ${num}`;\n   *  const queryRequest = queryBuilder.toQuery();\n   *  // produces:\n   *  { fql: [\"'foo'.length == \", { value: { \"@int\": \"8\" } }, \"\"] }\n   * ```\n   */\n  encode(): FQLFragment {\n    if (this.#queryFragments.length === 1) {\n      return { fql: [this.#queryFragments[0]] };\n    }\n\n    let renderedFragments: (string | QueryInterpolation)[] =\n      this.#queryFragments.flatMap((fragment, i) => {\n        // There will always be one more fragment than there are arguments\n        if (i === this.#queryFragments.length - 1) {\n          return fragment === \"\" ? [] : [fragment];\n        }\n\n        // arguments in the template format must always be encoded, regardless\n        // of the \"x-format\" request header\n        // TODO: catch and rethrow Errors, indicating bad user input\n        const arg = this.#interpolatedArgs[i];\n        const encoded = TaggedTypeFormat.encodeInterpolation(arg);\n\n        return [fragment, encoded];\n      });\n\n    // We don't need to send empty-string fragments over the wire\n    renderedFragments = renderedFragments.filter((x) => x !== \"\");\n\n    return { fql: renderedFragments };\n  }\n}\n", "//THIS FILE IS AUTOGENERATED. DO NOT EDIT. SEE .husky/pre-commit\n\n/** The current package version. */\nexport const packageVersion = \"2.4.0\";\n", "import { packageVersion } from \"./package-version\";\n\nlet os: any;\ntry {\n  os = require(\"node:os\");\n} catch (_) {\n  os = undefined;\n}\n\n/**\n * Function to put all of the environment details together.\n * @internal\n */\nexport const getDriverEnv = (): string => {\n  const driverEnv = {\n    driver: [\"javascript\", packageVersion].join(\"-\"),\n    env: \"unknown\",\n    os: \"unknown\",\n    runtime: \"unknown\",\n  };\n\n  try {\n    /**\n     * Determine if we're executing in a Node environment\n     */\n    const isNode =\n      typeof window === \"undefined\" &&\n      typeof process !== \"undefined\" &&\n      process.versions != null &&\n      process.versions.node != null;\n\n    /**\n     * Determine if we're executing in a Node environment\n     */\n    const isBrowser =\n      typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\n\n    /**\n     * Determine if we're executing in a Service Worker environment\n     */\n    const isServiceWorker =\n      typeof self === \"object\" &&\n      self.constructor &&\n      self.constructor.name === \"DedicatedWorkerGlobalScope\";\n\n    /**\n     * Determine if we're executing in Vercel's Edge Runtime\n     * @see {@link https://vercel.com/docs/concepts/functions/edge-functions/edge-runtime#check-if-you're-running-on-the-edge-runtime}\n     */\n    // @ts-expect-error Cannot find name 'EdgeRuntime'\n    const isVercelEdgeRuntime = typeof EdgeRuntime !== \"string\";\n\n    if (isNode) {\n      driverEnv.runtime = [\"nodejs\", process.version].join(\"-\");\n      driverEnv.env = getNodeRuntimeEnv();\n      driverEnv.os = [os.platform(), os.release()].join(\"-\");\n    } else if (isServiceWorker) {\n      driverEnv.runtime = getBrowserDetails(navigator);\n      driverEnv.env = \"Service Worker\";\n      driverEnv.os = getBrowserOsDetails(navigator);\n    } else if (isBrowser) {\n      driverEnv.runtime = getBrowserDetails(navigator);\n      driverEnv.env = \"browser\";\n      driverEnv.os = getBrowserOsDetails(navigator);\n    } else if (isVercelEdgeRuntime) {\n      driverEnv.runtime = \"Vercel Edge Runtime\";\n      driverEnv.env = \"edge\";\n    }\n  } catch (e) {\n    // ignore errors trying to report on user environment\n  }\n\n  return (\n    Object.entries(driverEnv)\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      .filter(([_, val]) => val !== \"unknown\")\n      .map((entry: [string, string]) => entry.join(\"=\"))\n      .join(\"; \")\n  );\n};\n\n/**\n * Get browser environment details\n */\nconst getBrowserDetails = (navigator: Navigator | WorkerNavigator): string => {\n  let browser: string = navigator.appName;\n  let browserVersion = \"\" + parseFloat(navigator.appVersion);\n  let nameOffset, verOffset, ix;\n\n  // Opera\n  if ((verOffset = navigator.userAgent.indexOf(\"Opera\")) != -1) {\n    browser = \"Opera\";\n    browserVersion = navigator.userAgent.substring(verOffset + 6);\n    if ((verOffset = navigator.userAgent.indexOf(\"Version\")) != -1) {\n      browserVersion = navigator.userAgent.substring(verOffset + 8);\n    }\n  }\n  // MSIE\n  else if ((verOffset = navigator.userAgent.indexOf(\"MSIE\")) != -1) {\n    browser = \"Microsoft Internet Explorer\";\n    browserVersion = navigator.userAgent.substring(verOffset + 5);\n  }\n\n  //IE 11 no longer identifies itself as MS IE, so trap it\n  //http://stackoverflow.com/questions/17907445/how-to-detect-ie11\n  else if (\n    browser == \"Netscape\" &&\n    navigator.userAgent.indexOf(\"Trident/\") != -1\n  ) {\n    browser = \"Microsoft Internet Explorer\";\n    browserVersion = navigator.userAgent.substring(verOffset + 5);\n    if ((verOffset = navigator.userAgent.indexOf(\"rv:\")) != -1) {\n      browserVersion = navigator.userAgent.substring(verOffset + 3);\n    }\n  }\n\n  // Chrome\n  else if ((verOffset = navigator.userAgent.indexOf(\"Chrome\")) != -1) {\n    browser = \"Chrome\";\n    browserVersion = navigator.userAgent.substring(verOffset + 7);\n  }\n  // Safari\n  else if ((verOffset = navigator.userAgent.indexOf(\"Safari\")) != -1) {\n    browser = \"Safari\";\n    browserVersion = navigator.userAgent.substring(verOffset + 7);\n    if ((verOffset = navigator.userAgent.indexOf(\"Version\")) != -1) {\n      browserVersion = navigator.userAgent.substring(verOffset + 8);\n    }\n\n    // Chrome on iPad identifies itself as Safari. Actual results do not match what Google claims\n    //  at: https://developers.google.com/chrome/mobile/docs/user-agent?hl=ja\n    //  No mention of chrome in the user agent string. However it does mention CriOS, which presumably\n    //  can be keyed on to detect it.\n    if (navigator.userAgent.indexOf(\"CriOS\") != -1) {\n      //Chrome on iPad spoofing Safari...correct it.\n      browser = \"Chrome\";\n      //Don't believe there is a way to grab the accurate version number, so leaving that for now.\n    }\n  }\n  // Firefox\n  else if ((verOffset = navigator.userAgent.indexOf(\"Firefox\")) != -1) {\n    browser = \"Firefox\";\n    browserVersion = navigator.userAgent.substring(verOffset + 8);\n  }\n  // Other browsers\n  else if (\n    (nameOffset = navigator.userAgent.lastIndexOf(\" \") + 1) <\n    (verOffset = navigator.userAgent.lastIndexOf(\"/\"))\n  ) {\n    browser = navigator.userAgent.substring(nameOffset, verOffset);\n    browserVersion = navigator.userAgent.substring(verOffset + 1);\n    if (browser.toLowerCase() == browser.toUpperCase()) {\n      browser = navigator.appName;\n    }\n  }\n  // trim the browser version string\n  if ((ix = browserVersion.indexOf(\";\")) != -1)\n    browserVersion = browserVersion.substring(0, ix);\n  if ((ix = browserVersion.indexOf(\" \")) != -1)\n    browserVersion = browserVersion.substring(0, ix);\n  if ((ix = browserVersion.indexOf(\")\")) != -1)\n    browserVersion = browserVersion.substring(0, ix);\n\n  return [browser, browserVersion].join(\"-\");\n};\n\n/**\n * Get OS details for the browser\n */\nconst getBrowserOsDetails = (\n  navigator: Navigator | WorkerNavigator\n): string => {\n  let os = \"unknown\";\n  const clientStrings = [\n    { s: \"Windows 10\", r: /(Windows 10.0|Windows NT 10.0)/ },\n    { s: \"Windows 8.1\", r: /(Windows 8.1|Windows NT 6.3)/ },\n    { s: \"Windows 8\", r: /(Windows 8|Windows NT 6.2)/ },\n    { s: \"Windows 7\", r: /(Windows 7|Windows NT 6.1)/ },\n    { s: \"Windows Vista\", r: /Windows NT 6.0/ },\n    { s: \"Windows Server 2003\", r: /Windows NT 5.2/ },\n    { s: \"Windows XP\", r: /(Windows NT 5.1|Windows XP)/ },\n    { s: \"Windows 2000\", r: /(Windows NT 5.0|Windows 2000)/ },\n    { s: \"Windows ME\", r: /(Win 9x 4.90|Windows ME)/ },\n    { s: \"Windows 98\", r: /(Windows 98|Win98)/ },\n    { s: \"Windows 95\", r: /(Windows 95|Win95|Windows_95)/ },\n    { s: \"Windows NT 4.0\", r: /(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/ },\n    { s: \"Windows CE\", r: /Windows CE/ },\n    { s: \"Windows 3.11\", r: /Win16/ },\n    { s: \"Android\", r: /Android/ },\n    { s: \"Open BSD\", r: /OpenBSD/ },\n    { s: \"Sun OS\", r: /SunOS/ },\n    { s: \"Chrome OS\", r: /CrOS/ },\n    { s: \"Linux\", r: /(Linux|X11(?!.*CrOS))/ },\n    { s: \"iOS\", r: /(iPhone|iPad|iPod)/ },\n    { s: \"Mac OS X\", r: /Mac OS X/ },\n    { s: \"Mac OS\", r: /(Mac OS|MacPPC|MacIntel|Mac_PowerPC|Macintosh)/ },\n    { s: \"QNX\", r: /QNX/ },\n    { s: \"UNIX\", r: /UNIX/ },\n    { s: \"BeOS\", r: /BeOS/ },\n    { s: \"OS/2\", r: /OS\\/2/ },\n    {\n      s: \"Search Bot\",\n      r: /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask Jeeves\\/Teoma|ia_archiver)/,\n    },\n  ];\n  for (const id in clientStrings) {\n    const cs = clientStrings[id];\n    if (cs.r.test(navigator.userAgent)) {\n      os = cs.s;\n      break;\n    }\n  }\n\n  let osVersion: string | undefined = \"unknown\";\n\n  if (/Windows/.test(os)) {\n    osVersion;\n    const matches = /Windows (.*)/.exec(os);\n    if (matches) {\n      osVersion = matches[1];\n    }\n    os = \"Windows\";\n  }\n\n  switch (os) {\n    case \"Mac OS\":\n    case \"Mac OS X\":\n    case \"Android\": {\n      const matches =\n        /(?:Android|Mac OS|Mac OS X|MacPPC|MacIntel|Mac_PowerPC|Macintosh) ([._\\d]+)/.exec(\n          navigator.userAgent\n        );\n      if (matches) {\n        osVersion = matches[1];\n      }\n      break;\n    }\n\n    case \"iOS\": {\n      const matches = /OS (\\d+)_(\\d+)_?(\\d+)?/.exec(navigator.appVersion);\n      if (matches) {\n        osVersion = matches[1] + \".\" + matches[2] + \".\" + (matches[3] ?? 0);\n      }\n      break;\n    }\n  }\n  return [os, osVersion].join(\"-\");\n};\n\nconst crossGlobal =\n  typeof window !== \"undefined\"\n    ? window\n    : typeof globalThis !== \"undefined\"\n    ? globalThis\n    : typeof global !== \"undefined\"\n    ? global\n    : self;\n\n/**\n * Get node environment details\n */\nconst getNodeRuntimeEnv = (): string => {\n  // return early if process variables are not available\n  if (\n    !(\n      typeof process !== \"undefined\" &&\n      process &&\n      process.env &&\n      typeof process.env === \"object\"\n    )\n  ) {\n    return \"unknown\";\n  }\n\n  const runtimeEnvs = [\n    {\n      name: \"Netlify\",\n      check: function (): boolean {\n        return !!process.env[\"NETLIFY_IMAGES_CDN_DOMAIN\"];\n      },\n    },\n    {\n      name: \"Vercel\",\n      check: function (): boolean {\n        return !!process.env[\"VERCEL\"];\n      },\n    },\n    {\n      name: \"Heroku\",\n      check: function (): boolean {\n        return (\n          !!process.env[\"PATH\"] && process.env.PATH.indexOf(\".heroku\") !== -1\n        );\n      },\n    },\n    {\n      name: \"AWS Lambda\",\n      check: function (): boolean {\n        return !!process.env[\"AWS_LAMBDA_FUNCTION_VERSION\"];\n      },\n    },\n    {\n      name: \"GCP Cloud Functions\",\n      check: function (): boolean {\n        return !!process.env[\"_\"] && process.env._.indexOf(\"google\") !== -1;\n      },\n    },\n    {\n      name: \"GCP Compute Instances\",\n      check: function (): boolean {\n        return !!process.env[\"GOOGLE_CLOUD_PROJECT\"];\n      },\n    },\n    {\n      name: \"Azure Cloud Functions\",\n      check: function (): boolean {\n        return !!process.env[\"WEBSITE_FUNCTIONS_AZUREMONITOR_CATEGORIES\"];\n      },\n    },\n    {\n      name: \"Azure Compute\",\n      check: function (): boolean {\n        return (\n          !!process.env[\"ORYX_ENV_TYPE\"] &&\n          !!process.env[\"WEBSITE_INSTANCE_ID\"] &&\n          process.env.ORYX_ENV_TYPE === \"AppService\"\n        );\n      },\n    },\n    {\n      name: \"Mongo Stitch\",\n      check: function (): boolean {\n        // @ts-expect-error Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature.ts(7017)\n        return typeof crossGlobal?.StitchError === \"function\";\n      },\n    },\n    {\n      name: \"Render\",\n      check: function (): boolean {\n        return !!process.env[\"RENDER_SERVICE_ID\"];\n      },\n    },\n    {\n      name: \"Begin\",\n      check: function (): boolean {\n        return !!process.env[\"BEGIN_DATA_SCOPE_ID\"];\n      },\n    },\n  ];\n  const detectedEnv = runtimeEnvs.find((env) => env.check());\n\n  return detectedEnv ? detectedEnv.name : \"unknown\";\n};\n", "export type RetryOptions = {\n  maxAttempts: number;\n  maxBackoff: number;\n  shouldRetry?: (error: any) => boolean;\n  attempt?: number;\n  sleepFn?: (callback: (args: void) => void, ms?: number) => void;\n};\n\nexport const withRetries = async <T>(\n  fn: () => Promise<T>,\n  {\n    maxAttempts,\n    maxBackoff,\n    shouldRetry = () => true,\n    attempt = 0,\n    sleepFn = setTimeout,\n  }: RetryOptions,\n): Promise<T> => {\n  const backoffMs =\n    attempt > 0\n      ? Math.min(Math.random() * 2 ** attempt, maxBackoff) * 1_000\n      : 0;\n  attempt += 1;\n\n  try {\n    return await fn();\n  } catch (error: any) {\n    if (attempt >= maxAttempts || shouldRetry(error) !== true) {\n      throw error;\n    }\n\n    await new Promise((resolve) => sleepFn(resolve, backoffMs));\n    return withRetries(fn, {\n      maxAttempts,\n      maxBackoff,\n      shouldRetry,\n      attempt,\n      sleepFn,\n    });\n  }\n};\n", "import { QueryArgumentObject } from \"./query-builder\";\nimport {\n  DateStub,\n  Document,\n  DocumentReference,\n  EmbeddedSet,\n  Module,\n  NamedDocument,\n  NamedDocumentReference,\n  NullDocument,\n  Page,\n  StreamToken,\n  TimeStub,\n} from \"./values\";\n\n/**\n * A request to make to Fauna.\n */\nexport interface QueryRequest<\n  T extends string | QueryInterpolation = string | QueryInterpolation,\n> {\n  /** The query */\n  query: T;\n\n  /** Optional arguments. Variables in the query will be initialized to the\n   * value associated with an argument key.\n   */\n  arguments?: EncodedObject;\n}\n\n/**\n * Options for queries. Each query can be made with different options. Settings here\n * take precedence over those in {@link ClientConfiguration}.\n */\nexport interface QueryOptions {\n  /** Optional arguments. Variables in the query will be initialized to the\n   * value associated with an argument key.\n   */\n  arguments?: QueryArgumentObject;\n\n  /**\n   * Determines the encoded format expected for the query `arguments` field, and\n   * the `data` field of a successful response.\n   * Overrides the optional setting on the {@link ClientConfiguration}.\n   */\n  format?: ValueFormat;\n\n  /**\n   * If true, unconditionally run the query as strictly serialized.\n   * This affects read-only transactions. Transactions which write\n   * will always be strictly serialized.\n   * Overrides the optional setting on the {@link ClientConfiguration}.\n   */\n  linearized?: boolean;\n\n  /**\n   * Controls what Javascript type to deserialize {@link https://docs.fauna.com/fauna/current/reference/fql_reference/types#long | Fauna longs} to.\n   * Use 'number' to deserialize longs to number. Use 'bigint' to deserialize to bigint. Defaults to 'number'.\n   * Note, for extremely large maginitude numbers Javascript's number will lose precision; as Javascript's\n   * 'number' can only support +/- 2^53-1 whereas Fauna's long is 64 bit. If this is detected, a warning will\n   * be logged to the console and precision loss will occur.\n   * If your application uses extremely large magnitude numbers use 'bigint'.\n   */\n  long_type?: \"number\" | \"bigint\";\n\n  /**\n   * The max number of times to retry the query if contention is encountered.\n   *Overrides the optional setting on the {@link ClientConfiguration}.\n   */\n  max_contention_retries?: number;\n\n  /**\n   * Tags provided back via logging and telemetry.\n   * Overrides the optional setting on the {@link ClientConfiguration}.\n   */\n  query_tags?: Record<string, string>;\n\n  /**\n   * The timeout to use in this query in milliseconds.\n   * Overrides the optional setting on the {@link ClientConfiguration}.\n   */\n  query_timeout_ms?: number;\n\n  /**\n   * A traceparent provided back via logging and telemetry.\n   * Must match format: https://www.w3.org/TR/trace-context/#traceparent-header\n   * Overrides the optional setting on the {@link ClientConfiguration}.\n   */\n  traceparent?: string;\n\n  /**\n   * Enable or disable typechecking of the query before evaluation. If no value\n   * is provided, the value of `typechecked` in the database configuration will\n   * be used.\n   * Overrides the optional setting on the {@link ClientConfiguration}.\n   */\n  typecheck?: boolean;\n\n  /**\n   * Enable or disable performance hints. Defaults to disabled.\n   * The QueryInfo object includes performance hints in the `summary` field, which is a\n   * top-level field in the response object.\n   * Overrides the optional setting on the {@link ClientConfiguration}.\n   */\n  performance_hints?: boolean;\n\n  /**\n   * Secret to use instead of the client's secret.\n   */\n  secret?: string;\n}\n\n/**\n * tagged declares that type information is transmitted and received by the driver.\n * \"simple\" indicates it is not - pure JSON is used.\n * \"decorated\" will cause the service output to be shown in FQL syntax that could\n * hypothetically be used to query Fauna. This is intended to support CLI and\n * REPL like tools.\n * @example\n * ```typescript\n * // example of decorated output\n * { time: Time(\"2012-01-01T00:00:00Z\") }\n * ```\n */\nexport declare type ValueFormat = \"simple\" | \"tagged\" | \"decorated\";\n\nexport type QueryStats = {\n  /** The amount of Transactional Compute Ops consumed by the query. */\n  compute_ops: number;\n  /** The amount of Transactional Read Ops consumed by the query. */\n  read_ops: number;\n  /** The amount of Transactional Write Ops consumed by the query. */\n  write_ops: number;\n  /** The query run time in milliseconds. */\n  query_time_ms: number;\n  /** The amount of data read from storage, in bytes. */\n  storage_bytes_read: number;\n  /** The amount of data written to storage, in bytes. */\n  storage_bytes_write: number;\n  /** The number of times the transaction was retried due to write contention. */\n  contention_retries: number;\n  /** The number query attempts made due to retryable errors. */\n  attempts: number;\n  /**\n   * A list of rate limits hit.\n   * Included with QueryFailure responses when the query is rate limited.\n   */\n  rate_limits_hit?: (\"read\" | \"write\" | \"compute\")[];\n};\n\nexport type QueryInfo = {\n  /** The last transaction timestamp of the query. A Unix epoch in microseconds. */\n  txn_ts?: number;\n  /** The schema version that was used for the query execution. */\n  schema_version?: number;\n  /** A readable summary of any warnings or logs emitted by the query. */\n  summary?: string;\n  /** The value of the x-query-tags header, if it was provided. */\n  query_tags?: Record<string, string>;\n  /** Stats on query performance and cost */\n  stats?: QueryStats;\n};\n\n/**\n * A decoded response from a successful query to Fauna\n */\nexport type QuerySuccess<T extends QueryValue> = QueryInfo & {\n  /**\n   * The result of the query. The data is any valid JSON value.\n   * @remarks\n   * data is type parameterized so that you can treat it as a\n   * certain type if you are using typescript.\n   */\n  data: T;\n  /** The query's inferred static result type. */\n  static_type?: string;\n};\n\n/**\n * A decoded response from a failed query to Fauna. Integrations which only want to report a human\n * readable version of the failure can simply print out the \"summary\" field.\n */\nexport type QueryFailure = QueryInfo & {\n  /**\n   * The result of the query resulting in\n   */\n  error: {\n    /** A predefined code which indicates the type of error. See XXX for a list of error codes. */\n    code: string;\n    /** A short, human readable description of the error */\n    message: string;\n    /**\n     * A machine readable description of any constraint failures encountered by the query.\n     * Present only if this query encountered constraint failures.\n     */\n    constraint_failures?: Array<ConstraintFailure>;\n    /**\n     * The user provided value passed to the originating `abort()` call.\n     * Present only when the query encountered an `abort()` call, which is\n     * denoted by the error code `\"abort\"`\n     */\n    abort?: QueryValue;\n  };\n};\n\n/**\n * A constraint failure triggered by a query.\n */\nexport type ConstraintFailure = {\n  /** Description of the constraint failure */\n  message: string;\n  /** Name of the failed constraint */\n  name?: string;\n  /** Path into the write input data to which the failure applies */\n  paths?: Array<Array<number | string>>;\n};\n\nexport type QueryResponse<T extends QueryValue> =\n  | QuerySuccess<T>\n  | QueryFailure;\n\nexport const isQuerySuccess = (res: any): res is QuerySuccess<any> =>\n  res instanceof Object && \"data\" in res;\n\nexport const isQueryFailure = (res: any): res is QueryFailure =>\n  res instanceof Object &&\n  \"error\" in res &&\n  res.error instanceof Object &&\n  \"code\" in res.error &&\n  \"message\" in res.error;\n\nexport const isQueryResponse = (res: any): res is QueryResponse<any> =>\n  isQueryResponse(res) || isQueryFailure(res);\n\n/**\n * A piece of an interpolated query. Interpolated queries can be safely composed\n * together without concern of query string injection.\n * @see {@link ValueFragment} and {@link FQLFragment} for additional\n * information\n */\nexport type QueryInterpolation =\n  | FQLFragment\n  | ValueFragment\n  | ObjectFragment\n  | ArrayFragment;\n\n/**\n * A piece of an interpolated query that represents an actual value. Arguments\n * are passed to fauna using ValueFragments so that query string injection is\n * not possible.\n * @remarks A ValueFragment is created by this driver when a literal value or\n * object is provided as an argument to the {@link fql} tagged template\n * function.\n *\n * ValueFragments must always be encoded with tags, regardless of the \"x-format\"\n * request header sent.\n * @example\n * ```typescript\n *  const num = 17;\n *  const query = fql`${num} + 3)`;\n *  // produces\n *  { \"fql\": [{ \"value\": { \"@int\": \"17\" } }, \" + 3\"] }\n * ```\n */\nexport type ValueFragment = { value: TaggedType };\n\n/**\n * A piece of an interpolated query that represents an object. Arguments\n * are passed to fauna using ObjectFragments so that query arguments can be\n * nested within javascript objects.\n *\n * ObjectFragments must always be encoded with tags, regardless of the\n * \"x-format\" request header sent.\n * @example\n * ```typescript\n *  const arg = { startDate: DateStub.from(\"2023-09-01\") };\n *  const query = fql`${arg})`;\n *  // produces\n *  {\n *\t\t\"fql\": [\n *\t\t\t{\n *\t\t\t\t\"object\": {\n *          \"startDate\": {\n *\t\t\t\t\t\t\"value\": { \"@date\": \"2023-09-01\" } // Object field values have type QueryInterpolation\n *\t\t\t\t\t}\n *\t\t\t\t}\n *\t\t\t}\n *\t\t]\n *\t}\n * ```\n */\nexport type ObjectFragment = { object: EncodedObject };\n\n/**\n * A piece of an interpolated query that represents an array. Arguments\n * are passed to fauna using ArrayFragments so that query arguments can be\n * nested within javascript arrays.\n *\n * ArrayFragments must always be encoded with tags, regardless of the \"x-format\"\n * request header sent.\n * @example\n * ```typescript\n *  const arg = [1, 2];\n *  const query = fql`${arg})`;\n *  // produces\n *  {\n *\t\t\"fql\": [\n *\t\t\t{\n *\t\t\t\t\"array\": [\n *\t\t\t\t\t{ \"value\": { \"@int\": \"1\" } }, // Array items have type QueryInterpolation\n *\t\t\t\t\t{ \"value\": { \"@int\": \"2\" } }\n *\t\t\t\t]\n *\t\t\t}\n *\t\t]\n *\t}\n * ```\n */\nexport type ArrayFragment = { array: TaggedType[] };\n\n/**\n * A piece of an interpolated query. Interpolated Queries can be safely composed\n * together without concern of query string injection.\n * @remarks A FQLFragment is created when calling the {@link fql} tagged\n * template function and can be passed as an argument to other Querys.\n * @example\n * ```typescript\n *  const num = 17;\n *  const query1 = fql`${num} + 3)`;\n *  const query2 = fql`5 + ${query1})`;\n *  // produces\n *  { \"fql\": [\"5 + \", { \"fql\": [{ \"value\": { \"@int\": \"17\" } }, \" + 3\"] }] }\n * ```\n */\nexport type FQLFragment = { fql: (string | QueryInterpolation)[] };\n\n/**\n * A source span indicating a segment of FQL.\n */\nexport interface Span {\n  /**\n   * A string identifier of the FQL source. For example, if performing\n   * a raw query against the API this would be *query*.\n   */\n  src: string;\n  /**\n   * The span's starting index within the src, inclusive.\n   */\n  start: number;\n  /**\n   * The span's ending index within the src, inclusive.\n   */\n  end: number;\n  /**\n   * The name of the enclosing function, if applicable.\n   */\n  function: string;\n}\n\n/**\n * A QueryValueObject is a plain javascript object where each value is a valid\n * QueryValue.\n * These objects can be returned in {@link QuerySuccess}.\n */\nexport interface QueryValueObject {\n  [key: string]: QueryValue;\n}\n\n/**\n * A QueryValue represents the possible return values in a {@link QuerySuccess}.\n */\nexport type QueryValue =\n  // plain javascript values\n  | null\n  | string\n  | number\n  | bigint\n  | boolean\n  | QueryValueObject\n  | Array<QueryValue>\n  | Uint8Array\n  // client-provided classes\n  | DateStub\n  | TimeStub\n  | Module\n  | Document\n  | DocumentReference\n  | NamedDocument\n  | NamedDocumentReference\n  | NullDocument\n  | Page<QueryValue>\n  | EmbeddedSet\n  | StreamToken;\n\nexport type StreamRequest = {\n  token: string;\n  start_ts?: number;\n  cursor?: string;\n};\n\nexport type StreamEventType = \"status\" | \"add\" | \"remove\" | \"update\" | \"error\";\nexport type StreamEventStatus = {\n  type: \"status\";\n  txn_ts: number;\n  cursor: string;\n  stats: QueryStats;\n};\nexport type StreamEventData<T extends QueryValue> = {\n  type: \"add\" | \"remove\" | \"update\";\n  txn_ts: number;\n  cursor: string;\n  stats: QueryStats;\n  data: T;\n};\nexport type StreamEventError = { type: \"error\" } & QueryFailure;\nexport type StreamEvent<T extends QueryValue> =\n  | StreamEventStatus\n  | StreamEventData<T>\n  | StreamEventError;\n\nexport type FeedRequest = StreamRequest & {\n  page_size?: number;\n};\n\nexport type FeedSuccess<T extends QueryValue> = {\n  events: (StreamEventData<T> | StreamEventError)[];\n  cursor: string;\n  has_next: boolean;\n  stats?: QueryStats;\n};\n\nexport type FeedError = QueryFailure;\n\nexport type TaggedBytes = { \"@bytes\": string };\nexport type TaggedDate = { \"@date\": string };\nexport type TaggedDouble = { \"@double\": string };\nexport type TaggedInt = { \"@int\": string };\nexport type TaggedLong = { \"@long\": string };\nexport type TaggedMod = { \"@mod\": string };\nexport type TaggedObject = { \"@object\": QueryValueObject };\nexport type TaggedRef = {\n  \"@ref\": { id: string; coll: TaggedMod } | { name: string; coll: TaggedMod };\n};\n// WIP: core does not accept `@set` tagged values\n// type TaggedSet = { \"@set\": { data: QueryValue[]; after?: string } };\nexport type TaggedTime = { \"@time\": string };\n\nexport type EncodedObject = { [key: string]: TaggedType };\n\nexport type TaggedType =\n  | string\n  | boolean\n  | null\n  | EncodedObject\n  | TaggedBytes\n  | TaggedDate\n  | TaggedDouble\n  | TaggedInt\n  | TaggedLong\n  | TaggedMod\n  | TaggedObject\n  | TaggedRef\n  | TaggedTime\n  | TaggedType[];\n", "import {\n  ClientConfiguration,\n  FeedClientConfiguration,\n  StreamClientConfiguration,\n  endpoints,\n} from \"./client-configuration\";\nimport {\n  ClientClosedError,\n  ClientError,\n  FaunaError,\n  NetworkError,\n  ProtocolError,\n  ServiceError,\n  ThrottlingError,\n  getServiceError,\n} from \"./errors\";\nimport {\n  FaunaAPIPaths,\n  HTTPRequest,\n  HTTPStreamClient,\n  StreamAdapter,\n  getDefaultHTTPClient,\n  isHTTPResponse,\n  isStreamClient,\n  type HTTPClient,\n} from \"./http-client\";\nimport { Query } from \"./query-builder\";\nimport { TaggedTypeFormat } from \"./tagged-type\";\nimport { getDriverEnv } from \"./util/environment\";\nimport { withRetries } from \"./util/retryable\";\nimport {\n  EmbeddedSet,\n  EventSource,\n  FeedPage,\n  Page,\n  SetIterator,\n  isEventSource,\n} from \"./values\";\nimport {\n  EncodedObject,\n  FeedError,\n  FeedRequest,\n  FeedSuccess,\n  QueryOptions,\n  QueryRequest,\n  StreamEvent,\n  StreamEventData,\n  StreamEventStatus,\n  isQueryFailure,\n  isQuerySuccess,\n  type QuerySuccess,\n  type QueryValue,\n} from \"./wire-protocol\";\n\ntype RequiredClientConfig = ClientConfiguration &\n  Required<\n    Pick<\n      ClientConfiguration,\n      | \"client_timeout_buffer_ms\"\n      | \"endpoint\"\n      | \"fetch_keepalive\"\n      | \"http2_max_streams\"\n      | \"http2_session_idle_ms\"\n      | \"secret\"\n      // required default query options\n      | \"format\"\n      | \"long_type\"\n      | \"query_timeout_ms\"\n      | \"max_attempts\"\n      | \"max_backoff\"\n    >\n  >;\n\nconst DEFAULT_CLIENT_CONFIG: Omit<\n  ClientConfiguration & RequiredClientConfig,\n  \"secret\" | \"endpoint\"\n> = {\n  client_timeout_buffer_ms: 5000,\n  format: \"tagged\",\n  http2_session_idle_ms: 5000,\n  http2_max_streams: 100,\n  long_type: \"number\",\n  fetch_keepalive: false,\n  query_timeout_ms: 5000,\n  max_attempts: 3,\n  max_backoff: 20,\n};\n\n/**\n * Client for calling Fauna.\n */\nexport class Client {\n  /** A static copy of the driver env header to send with each request */\n  static readonly #driverEnvHeader = getDriverEnv();\n\n  /** The {@link ClientConfiguration} */\n  readonly #clientConfiguration: RequiredClientConfig;\n  /** The underlying {@link HTTPClient} client. */\n  readonly #httpClient: HTTPClient & Partial<HTTPStreamClient>;\n  /** The last transaction timestamp this client has seen */\n  #lastTxnTs?: number;\n  /** true if this client is closed false otherwise */\n  #isClosed = false;\n\n  /**\n   * Constructs a new {@link Client}.\n   * @param clientConfiguration - the {@link ClientConfiguration} to apply. Defaults to recommended ClientConfiguraiton.\n   * @param httpClient - The underlying {@link HTTPClient} that will execute the actual HTTP calls. Defaults to recommended HTTPClient.\n   * @example\n   * ```typescript\n   *  const myClient = new Client(\n   *   {\n   *     endpoint: endpoints.cloud,\n   *     secret: \"foo\",\n   *     query_timeout_ms: 60_000,\n   *   }\n   * );\n   * ```\n   */\n  constructor(\n    clientConfiguration?: ClientConfiguration,\n    httpClient?: HTTPClient,\n  ) {\n    this.#clientConfiguration = {\n      ...DEFAULT_CLIENT_CONFIG,\n      ...clientConfiguration,\n      secret: this.#getSecret(clientConfiguration),\n      endpoint: this.#getEndpoint(clientConfiguration),\n    };\n\n    this.#validateConfiguration();\n\n    if (!httpClient) {\n      this.#httpClient = getDefaultHTTPClient({\n        url: this.#clientConfiguration.endpoint.toString(),\n        http2_session_idle_ms: this.#clientConfiguration.http2_session_idle_ms,\n        http2_max_streams: this.#clientConfiguration.http2_max_streams,\n        fetch_keepalive: this.#clientConfiguration.fetch_keepalive,\n      });\n    } else {\n      this.#httpClient = httpClient;\n    }\n  }\n\n  /**\n   * @returns the last transaction time seen by this client, or undefined if this client has not seen a transaction time.\n   */\n  get lastTxnTs(): number | undefined {\n    return this.#lastTxnTs;\n  }\n  /**\n   * Sets the last transaction time of this client.\n   * @param ts - the last transaction timestamp to set, as microseconds since\n   *   the epoch. If `ts` is less than the existing `#lastTxnTs` value or is\n   *   undefined , then no change is made.\n   */\n  set lastTxnTs(ts: number | undefined) {\n    if (ts !== undefined) {\n      this.#lastTxnTs = this.#lastTxnTs ? Math.max(ts, this.#lastTxnTs) : ts;\n    }\n  }\n\n  /**\n   * Return the {@link ClientConfiguration} of this client.\n   */\n  get clientConfiguration(): ClientConfiguration {\n    const { ...copy } = this.#clientConfiguration;\n    return copy;\n  }\n\n  /**\n   * Closes the underlying HTTP client. Subsequent query or close calls\n   * will fail.\n   */\n  close() {\n    if (this.#isClosed) {\n      throw new ClientClosedError(\n        \"Your client is closed. You cannot close it again.\",\n      );\n    }\n    this.#httpClient.close();\n    this.#isClosed = true;\n  }\n\n  /**\n   * Creates an iterator to yield pages of data. If additional pages exist, the\n   * iterator will lazily fetch addition pages on each iteration. Pages will\n   * be retried in the event of a ThrottlingError up to the client's configured\n   * max_attempts, inclusive of the initial call.\n   *\n   * @typeParam T - The expected type of the items returned from Fauna on each\n   * iteration. T can be inferred if the provided query used a type parameter.\n   * @param iterable - a {@link Query} or an existing fauna Set ({@link Page} or\n   * {@link EmbeddedSet})\n   * @param options - a {@link QueryOptions} to apply to the queries. Optional.\n   * @returns A {@link SetIterator} that lazily fetches new pages of data on\n   * each iteration\n   *\n   * @example\n   * ```javascript\n   *  const userIterator = await client.paginate(fql`\n   *    Users.all()\n   *  `);\n   *\n   *  for await (const users of userIterator) {\n   *    for (const user of users) {\n   *      // do something with each user\n   *    }\n   *  }\n   * ```\n   *\n   * @example\n   * The {@link SetIterator.flatten} method can be used so the iterator yields\n   * items directly. Each item is fetched asynchronously and hides when\n   * additional pages are fetched.\n   *\n   * ```javascript\n   *  const userIterator = await client.paginate(fql`\n   *    Users.all()\n   *  `);\n   *\n   *  for await (const user of userIterator.flatten()) {\n   *    // do something with each user\n   *  }\n   * ```\n   */\n  paginate<T extends QueryValue>(\n    iterable: Page<T> | EmbeddedSet | Query<T | Page<T>>,\n    options?: QueryOptions,\n  ): SetIterator<T> {\n    if (iterable instanceof Query) {\n      return SetIterator.fromQuery(this, iterable, options);\n    }\n    return SetIterator.fromPageable(this, iterable, options) as SetIterator<T>;\n  }\n\n  /**\n   * Queries Fauna. Queries will be retried in the event of a ThrottlingError up to the client's configured\n   * max_attempts, inclusive of the initial call.\n   *\n   * @typeParam T - The expected type of the response from Fauna. T can be inferred if the\n   *   provided query used a type parameter.\n   * @param query - a {@link Query} to execute in Fauna.\n   *   Note, you can embed header fields in this object; if you do that there's no need to\n   *   pass the headers parameter.\n   * @param options - optional {@link QueryOptions} to apply on top of the request input.\n   *   Values in this headers parameter take precedence over the same values in the {@link ClientConfiguration}.\n   * @returns Promise&lt;{@link QuerySuccess}&gt;.\n   *\n   * @throws {@link ServiceError} Fauna emitted an error. The ServiceError will be\n   *   one of ServiceError's child classes if the error can be further categorized,\n   *   or a concrete ServiceError if it cannot.\n   *   You can use either the type, or the underlying httpStatus + code to determine\n   *   the root cause.\n   * @throws {@link ProtocolError} the client a HTTP error not sent by Fauna.\n   * @throws {@link NetworkError} the client encountered a network issue\n   * connecting to Fauna.\n   * @throws A {@link ClientError} the client fails to submit the request\n   * @throws {@link ClientClosedError} if a query is issued after the client is closed.\n   * due to an internal error.\n   */\n  async query<T extends QueryValue>(\n    query: Query<T>,\n    options?: QueryOptions,\n  ): Promise<QuerySuccess<T>> {\n    if (this.#isClosed) {\n      throw new ClientClosedError(\n        \"Your client is closed. No further requests can be issued.\",\n      );\n    }\n\n    const request: QueryRequest = {\n      query: query.encode(),\n    };\n\n    if (options?.arguments) {\n      request.arguments = TaggedTypeFormat.encode(\n        options.arguments,\n      ) as EncodedObject;\n    }\n\n    return this.#queryWithRetries(request, options);\n  }\n\n  /**\n   * Initialize a streaming request to Fauna\n   * @typeParam T - The expected type of the response from Fauna. T can be inferred\n   *   if the provided query used a type parameter.\n   * @param tokenOrQuery - A string-encoded token for an {@link EventSource}, or a {@link Query}\n   * @returns A {@link StreamClient} that which can be used to listen to a stream\n   *   of events\n   *\n   * @example\n   * ```javascript\n   *  const stream = client.stream(fql`MyCollection.all().eventSource()`)\n   *\n   *  try {\n   *    for await (const event of stream) {\n   *      switch (event.type) {\n   *        case \"update\":\n   *        case \"add\":\n   *        case \"remove\":\n   *          console.log(\"Stream update:\", event);\n   *          // ...\n   *          break;\n   *      }\n   *    }\n   *  } catch (error) {\n   *    // An error will be handled here if Fauna returns a terminal, \"error\" event, or\n   *    // if Fauna returns a non-200 response when trying to connect, or\n   *    // if the max number of retries on network errors is reached.\n   *\n   *    // ... handle fatal error\n   *  };\n   * ```\n   *\n   * @example\n   * ```javascript\n   *  const stream = client.stream(fql`MyCollection.all().eventSource()`)\n   *\n   *  stream.start(\n   *    function onEvent(event) {\n   *      switch (event.type) {\n   *        case \"update\":\n   *        case \"add\":\n   *        case \"remove\":\n   *          console.log(\"Stream update:\", event);\n   *          // ...\n   *          break;\n   *      }\n   *    },\n   *    function onError(error) {\n   *      // An error will be handled here if Fauna returns a terminal, \"error\" event, or\n   *      // if Fauna returns a non-200 response when trying to connect, or\n   *      // if the max number of retries on network errors is reached.\n   *\n   *      // ... handle fatal error\n   *    }\n   *  );\n   * ```\n   */\n  stream<T extends QueryValue>(\n    tokenOrQuery: EventSource | Query<EventSource>,\n    options?: Partial<StreamClientConfiguration>,\n  ): StreamClient<T> {\n    if (this.#isClosed) {\n      throw new ClientClosedError(\n        \"Your client is closed. No further requests can be issued.\",\n      );\n    }\n\n    const streamClient = this.#httpClient;\n\n    if (isStreamClient(streamClient)) {\n      const streamClientConfig: StreamClientConfiguration = {\n        ...this.#clientConfiguration,\n        httpStreamClient: streamClient,\n        ...options,\n      };\n\n      if (\n        streamClientConfig.cursor !== undefined &&\n        tokenOrQuery instanceof Query\n      ) {\n        throw new ClientError(\n          \"The `cursor` configuration can only be used with a stream token.\",\n        );\n      }\n\n      const tokenOrGetToken =\n        tokenOrQuery instanceof Query\n          ? () => this.query<EventSource>(tokenOrQuery).then((res) => res.data)\n          : tokenOrQuery;\n\n      return new StreamClient(tokenOrGetToken, streamClientConfig);\n    } else {\n      throw new ClientError(\"Streaming is not supported by this client.\");\n    }\n  }\n\n  /**\n   * Initialize a event feed in Fauna and returns an asynchronous iterator of\n   * feed events.\n   * @typeParam T - The expected type of the response from Fauna. T can be inferred\n   *   if the provided query used a type parameter.\n   * @param tokenOrQuery - A string-encoded token for an {@link EventSource}, or a {@link Query}\n   * @returns A {@link FeedClient} that which can be used to listen to a feed\n   *   of events\n   *\n   * @example\n   * ```javascript\n   *  const feed = client.feed(fql`MyCollection.all().eventSource()`)\n   *\n   *  try {\n   *    for await (const page of feed) {\n   *      for (const event of page.events) {\n   *        // ... handle event\n   *      }\n   *    }\n   *  } catch (error) {\n   *    // An error will be handled here if Fauna returns a terminal, \"error\" event, or\n   *    // if Fauna returns a non-200 response when trying to connect, or\n   *    // if the max number of retries on network errors is reached.\n   *\n   *    // ... handle fatal error\n   *  };\n   * ```\n   * @example\n   * The {@link FeedClient.flatten} method can be used so the iterator yields\n   * events directly. Each event is fetched asynchronously and hides when\n   * additional pages are fetched.\n   *\n   * ```javascript\n   *  const feed = client.feed(fql`MyCollection.all().eventSource()`)\n   *\n   *  for await (const user of feed.flatten()) {\n   *    // do something with each event\n   *  }\n   * ```\n   */\n  feed<T extends QueryValue>(\n    tokenOrQuery: EventSource | Query<EventSource>,\n    options?: Partial<FeedClientConfiguration>,\n  ): FeedClient<T> {\n    if (this.#isClosed) {\n      throw new ClientClosedError(\n        \"Your client is closed. No further requests can be issued.\",\n      );\n    }\n\n    const clientConfiguration: FeedClientConfiguration = {\n      ...this.#clientConfiguration,\n      httpClient: this.#httpClient,\n      ...options,\n    };\n\n    const tokenOrGetToken =\n      tokenOrQuery instanceof Query\n        ? () => this.query<EventSource>(tokenOrQuery).then((res) => res.data)\n        : tokenOrQuery;\n\n    return new FeedClient(tokenOrGetToken, clientConfiguration);\n  }\n\n  async #queryWithRetries<T extends QueryValue>(\n    queryRequest: QueryRequest,\n    queryOptions?: QueryOptions,\n    attempt = 0,\n  ): Promise<QuerySuccess<T>> {\n    const maxBackoff =\n      this.clientConfiguration.max_backoff ?? DEFAULT_CLIENT_CONFIG.max_backoff;\n    const maxAttempts =\n      this.clientConfiguration.max_attempts ??\n      DEFAULT_CLIENT_CONFIG.max_attempts;\n    const backoffMs =\n      Math.min(Math.random() * 2 ** attempt, maxBackoff) * 1_000;\n\n    attempt += 1;\n\n    try {\n      return await this.#query<T>(queryRequest, queryOptions, attempt);\n    } catch (error) {\n      if (error instanceof ThrottlingError && attempt < maxAttempts) {\n        await wait(backoffMs);\n        return this.#queryWithRetries<T>(queryRequest, queryOptions, attempt);\n      }\n      throw error;\n    }\n  }\n\n  #getError(e: any): ClientError | NetworkError | ProtocolError | ServiceError {\n    // the error was already handled by the driver\n    if (\n      e instanceof ClientError ||\n      e instanceof NetworkError ||\n      e instanceof ProtocolError ||\n      e instanceof ServiceError\n    ) {\n      return e;\n    }\n\n    // the HTTP request succeeded, but there was an error\n    if (isHTTPResponse(e)) {\n      // we got an error from the fauna service\n      if (isQueryFailure(e.body)) {\n        const failure = e.body;\n        const status = e.status;\n        return getServiceError(failure, status);\n      }\n\n      // we got a different error from the protocol layer\n      return new ProtocolError({\n        message: `Response is in an unkown format: ${e.body}`,\n        httpStatus: e.status,\n      });\n    }\n\n    // unknown error\n    return new ClientError(\n      \"A client level error occurred. Fauna was not called.\",\n      {\n        cause: e,\n      },\n    );\n  }\n\n  #getSecret(partialClientConfig?: ClientConfiguration): string {\n    let env_secret = undefined;\n    if (\n      typeof process !== \"undefined\" &&\n      process &&\n      typeof process === \"object\" &&\n      process.env &&\n      typeof process.env === \"object\"\n    ) {\n      env_secret = process.env[\"FAUNA_SECRET\"];\n    }\n\n    const maybeSecret = partialClientConfig?.secret ?? env_secret;\n    if (maybeSecret === undefined) {\n      throw new TypeError(\n        \"You must provide a secret to the driver. Set it \\\nin an environmental variable named FAUNA_SECRET or pass it to the Client\\\n constructor.\",\n      );\n    }\n    return maybeSecret;\n  }\n\n  #getEndpoint(partialClientConfig?: ClientConfiguration): URL {\n    // If the user explicitly sets the endpoint to undefined, we should throw a\n    // TypeError, rather than override with the default endpoint.\n    if (\n      partialClientConfig &&\n      \"endpoint\" in partialClientConfig &&\n      partialClientConfig.endpoint === undefined\n    ) {\n      throw new TypeError(\n        `ClientConfiguration option endpoint must be defined.`,\n      );\n    }\n\n    let env_endpoint: URL | undefined = undefined;\n    if (\n      typeof process !== \"undefined\" &&\n      process &&\n      typeof process === \"object\" &&\n      process.env &&\n      typeof process.env === \"object\"\n    ) {\n      env_endpoint = process.env[\"FAUNA_ENDPOINT\"]\n        ? new URL(process.env[\"FAUNA_ENDPOINT\"])\n        : undefined;\n    }\n\n    return partialClientConfig?.endpoint ?? env_endpoint ?? endpoints.default;\n  }\n\n  async #query<T extends QueryValue>(\n    queryRequest: QueryRequest,\n    queryOptions?: QueryOptions,\n    attempt = 0,\n  ): Promise<QuerySuccess<T>> {\n    try {\n      const requestConfig = {\n        ...this.#clientConfiguration,\n        ...queryOptions,\n      };\n\n      const headers = {\n        Authorization: `Bearer ${requestConfig.secret}`,\n      };\n      this.#setHeaders(requestConfig, headers);\n\n      const isTaggedFormat = requestConfig.format === \"tagged\";\n\n      const client_timeout_ms =\n        requestConfig.query_timeout_ms +\n        this.#clientConfiguration.client_timeout_buffer_ms;\n\n      const response = await this.#httpClient.request({\n        client_timeout_ms,\n        data: queryRequest,\n        headers,\n        method: \"POST\",\n      });\n\n      let parsedResponse;\n      try {\n        parsedResponse = {\n          ...response,\n          body: isTaggedFormat\n            ? TaggedTypeFormat.decode(response.body, {\n                long_type: requestConfig.long_type,\n              })\n            : JSON.parse(response.body),\n        };\n        if (parsedResponse.body.query_tags) {\n          const tags_array = (parsedResponse.body.query_tags as string)\n            .split(\",\")\n            .map((tag) => tag.split(\"=\"));\n          parsedResponse.body.query_tags = Object.fromEntries(tags_array);\n        }\n      } catch (error: unknown) {\n        throw new ProtocolError({\n          message: `Error parsing response as JSON: ${error}`,\n          httpStatus: response.status,\n        });\n      }\n\n      // Response is not from Fauna\n      if (!isQuerySuccess(parsedResponse.body)) {\n        throw this.#getError(parsedResponse);\n      }\n\n      const txn_ts = parsedResponse.body.txn_ts;\n      if (\n        (this.#lastTxnTs === undefined && txn_ts !== undefined) ||\n        (txn_ts !== undefined &&\n          this.#lastTxnTs !== undefined &&\n          this.#lastTxnTs < txn_ts)\n      ) {\n        this.#lastTxnTs = txn_ts;\n      }\n\n      const res = parsedResponse.body as QuerySuccess<T>;\n      if (res.stats) {\n        res.stats.attempts = attempt;\n      }\n      return res;\n    } catch (e: any) {\n      throw this.#getError(e);\n    }\n  }\n\n  #setHeaders(\n    fromObject: QueryOptions,\n    headerObject: Record<string, string | number>,\n  ): void {\n    const setHeader = <V>(\n      header: string,\n      value: V | undefined,\n      transform: (v: V) => string | number = (v) => String(v),\n    ) => {\n      if (value !== undefined) {\n        headerObject[header] = transform(value);\n      }\n    };\n\n    setHeader(\"x-format\", fromObject.format);\n    setHeader(\"x-typecheck\", fromObject.typecheck);\n    setHeader(\"x-performance-hints\", fromObject.performance_hints);\n    setHeader(\"x-query-timeout-ms\", fromObject.query_timeout_ms);\n    setHeader(\"x-linearized\", fromObject.linearized);\n    setHeader(\"x-max-contention-retries\", fromObject.max_contention_retries);\n    setHeader(\"traceparent\", fromObject.traceparent);\n    setHeader(\"x-query-tags\", fromObject.query_tags, (tags) =>\n      Object.entries(tags)\n        .map((tag) => tag.join(\"=\"))\n        .join(\",\"),\n    );\n    setHeader(\"x-last-txn-ts\", this.#lastTxnTs, (v) => v); // x-last-txn-ts doesn't get stringified\n    setHeader(\"x-driver-env\", Client.#driverEnvHeader);\n  }\n\n  #validateConfiguration() {\n    const config = this.#clientConfiguration;\n\n    const required_options: (keyof RequiredClientConfig)[] = [\n      \"client_timeout_buffer_ms\",\n      \"endpoint\",\n      \"format\",\n      \"http2_session_idle_ms\",\n      \"long_type\",\n      \"query_timeout_ms\",\n      \"fetch_keepalive\",\n      \"http2_max_streams\",\n      \"max_backoff\",\n      \"max_attempts\",\n    ];\n    required_options.forEach((option) => {\n      if (config[option] === undefined) {\n        throw new TypeError(\n          `ClientConfiguration option '${option}' must be defined.`,\n        );\n      }\n    });\n\n    if (config.http2_max_streams <= 0) {\n      throw new RangeError(`'http2_max_streams' must be greater than zero.`);\n    }\n\n    if (config.client_timeout_buffer_ms <= 0) {\n      throw new RangeError(\n        `'client_timeout_buffer_ms' must be greater than zero.`,\n      );\n    }\n\n    if (config.query_timeout_ms <= 0) {\n      throw new RangeError(`'query_timeout_ms' must be greater than zero.`);\n    }\n\n    if (config.max_backoff <= 0) {\n      throw new RangeError(`'max_backoff' must be greater than zero.`);\n    }\n\n    if (config.max_attempts <= 0) {\n      throw new RangeError(`'max_attempts' must be greater than zero.`);\n    }\n  }\n}\n\n/**\n * A class to listen to Fauna streams.\n */\nexport class StreamClient<T extends QueryValue = any> {\n  /** Whether or not this stream has been closed */\n  closed = false;\n  /** The stream client options */\n  #clientConfiguration: StreamClientConfiguration;\n  /** A tracker for the number of connection attempts */\n  #connectionAttempts = 0;\n  /** A lambda that returns a promise for a {@link EventSource} */\n  #query: () => Promise<EventSource>;\n  /** The last `txn_ts` value received from events */\n  #last_ts?: number;\n  /** The last `cursor` value received from events */\n  #last_cursor?: string;\n  /** A common interface to operate a stream from any HTTPStreamClient */\n  #streamAdapter?: StreamAdapter;\n  /** A saved copy of the EventSource once received */\n  #eventSource?: EventSource;\n\n  /**\n   *\n   * @param token - A lambda that returns a promise for a {@link EventSource}\n   * @param clientConfiguration - The {@link ClientConfiguration} to apply\n   * @example\n   * ```typescript\n   *  const streamClient = client.stream(eventSource);\n   * ```\n   */\n  constructor(\n    token: EventSource | (() => Promise<EventSource>),\n    clientConfiguration: StreamClientConfiguration,\n  ) {\n    if (isEventSource(token)) {\n      this.#query = () => Promise.resolve(token);\n    } else {\n      this.#query = token;\n    }\n\n    this.#clientConfiguration = clientConfiguration;\n\n    this.#validateConfiguration();\n  }\n\n  /**\n   * A synchronous method to start listening to the stream and handle events\n   * using callbacks.\n   * @param onEvent - A callback function to handle each event\n   * @param onError - An Optional callback function to handle errors. If none is\n   * provided, error will not be handled, and the stream will simply end.\n   */\n  start(\n    onEvent: (event: StreamEventData<T> | StreamEventStatus) => void,\n    onError?: (error: Error) => void,\n  ) {\n    if (typeof onEvent !== \"function\") {\n      throw new TypeError(\n        `Expected a function as the 'onEvent' argument, but received ${typeof onEvent}. Please provide a valid function.`,\n      );\n    }\n    if (onError && typeof onError !== \"function\") {\n      throw new TypeError(\n        `Expected a function as the 'onError' argument, but received ${typeof onError}. Please provide a valid function.`,\n      );\n    }\n    const run = async () => {\n      try {\n        for await (const event of this) {\n          onEvent(event);\n        }\n      } catch (error) {\n        if (onError) {\n          onError(error as Error);\n        }\n      }\n    };\n    run();\n  }\n\n  async *[Symbol.asyncIterator](): AsyncGenerator<\n    StreamEventData<T> | StreamEventStatus\n  > {\n    if (this.closed) {\n      throw new ClientError(\"The stream has been closed and cannot be reused.\");\n    }\n\n    if (!this.#eventSource) {\n      this.#eventSource = await this.#query().then((maybeStreamToken) => {\n        if (!isEventSource(maybeStreamToken)) {\n          throw new ClientError(\n            `Error requesting a stream token. Expected a EventSource as the query result, but received ${typeof maybeStreamToken}. Your query must return the result of '<Set>.eventSource' or '<Set>.eventsOn')\\n` +\n              `Query result: ${JSON.stringify(maybeStreamToken, null)}`,\n          );\n        }\n        return maybeStreamToken;\n      });\n    }\n\n    this.#connectionAttempts = 1;\n    while (!this.closed) {\n      const backoffMs =\n        Math.min(\n          Math.random() * 2 ** this.#connectionAttempts,\n          this.#clientConfiguration.max_backoff,\n        ) * 1_000;\n\n      try {\n        for await (const event of this.#startStream()) {\n          yield event;\n        }\n      } catch (error: any) {\n        if (\n          error instanceof FaunaError ||\n          this.#connectionAttempts >= this.#clientConfiguration.max_attempts\n        ) {\n          // A terminal error from Fauna\n          this.close();\n          throw error;\n        }\n\n        this.#connectionAttempts += 1;\n        await wait(backoffMs);\n      }\n    }\n  }\n\n  close() {\n    if (this.#streamAdapter) {\n      this.#streamAdapter.close();\n      this.#streamAdapter = undefined;\n    }\n    this.closed = true;\n  }\n\n  get last_ts(): number | undefined {\n    return this.#last_ts;\n  }\n\n  async *#startStream(): AsyncGenerator<\n    StreamEventData<T> | StreamEventStatus\n  > {\n    // Safety: This method must only be called after a stream token has been acquired\n    const eventSource = this.#eventSource as EventSource;\n\n    const headers = {\n      Authorization: `Bearer ${this.#clientConfiguration.secret}`,\n    };\n\n    const streamAdapter = this.#clientConfiguration.httpStreamClient.stream({\n      data: {\n        token: eventSource.token,\n        cursor: this.#last_cursor || this.#clientConfiguration.cursor,\n      },\n      headers,\n      method: \"POST\",\n    });\n\n    this.#streamAdapter = streamAdapter;\n\n    for await (const event of streamAdapter.read) {\n      // stream events are always tagged\n      const deserializedEvent: StreamEvent<T> = TaggedTypeFormat.decode(event, {\n        long_type: this.#clientConfiguration.long_type,\n      });\n\n      if (deserializedEvent.type === \"error\") {\n        // Errors sent from Fauna are assumed fatal\n        this.close();\n        throw getServiceError(deserializedEvent);\n      }\n\n      this.#last_ts = deserializedEvent.txn_ts;\n      this.#last_cursor = deserializedEvent.cursor;\n\n      // TODO: remove this once all environments have updated the events to use \"status\" instead of \"start\"\n      if ((deserializedEvent.type as any) === \"start\") {\n        deserializedEvent.type = \"status\";\n      }\n\n      if (\n        !this.#clientConfiguration.status_events &&\n        deserializedEvent.type === \"status\"\n      ) {\n        continue;\n      }\n\n      yield deserializedEvent;\n    }\n  }\n\n  #validateConfiguration() {\n    const config = this.#clientConfiguration;\n\n    const required_options: (keyof StreamClientConfiguration)[] = [\n      \"long_type\",\n      \"httpStreamClient\",\n      \"max_backoff\",\n      \"max_attempts\",\n      \"secret\",\n    ];\n    required_options.forEach((option) => {\n      if (config[option] === undefined) {\n        throw new TypeError(\n          `ClientConfiguration option '${option}' must be defined.`,\n        );\n      }\n    });\n\n    if (config.max_backoff <= 0) {\n      throw new RangeError(`'max_backoff' must be greater than zero.`);\n    }\n\n    if (config.max_attempts <= 0) {\n      throw new RangeError(`'max_attempts' must be greater than zero.`);\n    }\n  }\n}\n\n/**\n * A class to iterate through to a Fauna event feed.\n */\nexport class FeedClient<T extends QueryValue = any> {\n  /** A static copy of the driver env header to send with each request */\n  static readonly #driverEnvHeader = getDriverEnv();\n  /** A lambda that returns a promise for a {@link EventSource} */\n  #query: () => Promise<EventSource>;\n  /** The event feed's client options */\n  #clientConfiguration: FeedClientConfiguration;\n  /** The last `cursor` value received for the current page */\n  #lastCursor?: string;\n  /** A saved copy of the EventSource once received */\n  #eventSource?: EventSource;\n  /** Whether or not another page can be fetched by the client */\n  #isDone?: boolean;\n\n  /**\n   *\n   * @param token - A lambda that returns a promise for a {@link EventSource}\n   * @param clientConfiguration - The {@link FeedClientConfiguration} to apply\n   * @example\n   * ```typescript\n   *  const feed = client.feed(eventSource);\n   * ```\n   */\n  constructor(\n    token: EventSource | (() => Promise<EventSource>),\n    clientConfiguration: FeedClientConfiguration,\n  ) {\n    if (isEventSource(token)) {\n      this.#query = () => Promise.resolve(token);\n    } else {\n      this.#query = token;\n    }\n\n    this.#clientConfiguration = clientConfiguration;\n    this.#lastCursor = clientConfiguration.cursor;\n\n    this.#validateConfiguration();\n  }\n\n  #getHeaders(): Record<string, string> {\n    return {\n      Authorization: `Bearer ${this.#clientConfiguration.secret}`,\n      \"x-format\": \"tagged\",\n      \"x-driver-env\": FeedClient.#driverEnvHeader,\n      \"x-query-timeout-ms\":\n        this.#clientConfiguration.query_timeout_ms.toString(),\n    };\n  }\n\n  async #nextPageHttpRequest() {\n    // If we never resolved the stream token, do it now since we need it here when\n    // building the payload\n    if (!this.#eventSource) {\n      this.#eventSource = await this.#resolveEventSource(this.#query);\n    }\n\n    const headers = this.#getHeaders();\n\n    const req: HTTPRequest<FeedRequest> = {\n      headers,\n      client_timeout_ms:\n        this.#clientConfiguration.client_timeout_buffer_ms +\n        this.#clientConfiguration.query_timeout_ms,\n      data: {\n        token: this.#eventSource.token,\n      },\n      method: \"POST\",\n      path: FaunaAPIPaths.EVENT_FEED,\n    };\n\n    // Set the page size if it is available\n    if (this.#clientConfiguration.page_size) {\n      req.data.page_size = this.#clientConfiguration.page_size;\n    }\n\n    // If we have a cursor, use that. Otherwise, use the start_ts if available.\n    // When the config is validated, if both are set, an error is thrown.\n    if (this.#lastCursor) {\n      req.data.cursor = this.#lastCursor;\n    } else if (this.#clientConfiguration.start_ts) {\n      req.data.start_ts = this.#clientConfiguration.start_ts;\n    }\n\n    return req;\n  }\n\n  async *[Symbol.asyncIterator](): AsyncGenerator<FeedPage<T>> {\n    while (!this.#isDone) {\n      yield await this.nextPage();\n    }\n  }\n\n  /**\n   * Fetches the next page of the event feed. If there are no more pages to\n   * fetch, this method will throw a {@link ClientError}.\n   */\n  async nextPage(): Promise<FeedPage<T>> {\n    if (this.#isDone) {\n      throw new ClientError(\"The event feed has no more pages to fetch.\");\n    }\n\n    const { httpClient } = this.#clientConfiguration;\n\n    const request = await this.#nextPageHttpRequest();\n    const response = await withRetries(() => httpClient.request(request), {\n      maxAttempts: this.#clientConfiguration.max_attempts,\n      maxBackoff: this.#clientConfiguration.max_backoff,\n      shouldRetry: (error) => error instanceof ThrottlingError,\n    });\n\n    let body: FeedSuccess<T> | FeedError;\n\n    try {\n      body = TaggedTypeFormat.decode(response.body, {\n        long_type: this.#clientConfiguration.long_type,\n      });\n    } catch (error: unknown) {\n      throw new ProtocolError({\n        message: `Error parsing response as JSON: ${error}`,\n        httpStatus: response.status,\n      });\n    }\n\n    if (isQueryFailure(body)) {\n      throw getServiceError(body, response.status);\n    }\n\n    const page = new FeedPage<T>(body);\n    this.#lastCursor = page.cursor;\n    this.#isDone = !page.hasNext;\n\n    return page;\n  }\n\n  /**\n   * Returns an async generator that yields the events of the event feed\n   * directly.\n   *\n   * @example\n   * ```javascript\n   *  const feed = client.feed(fql`MyCollection.all().eventSource()`)\n   *\n   *  for await (const user of feed.flatten()) {\n   *    // do something with each event\n   *  }\n   * ```\n   */\n  async *flatten(): AsyncGenerator<StreamEventData<T>> {\n    for await (const page of this) {\n      for (const event of page.events) {\n        yield event;\n      }\n    }\n  }\n\n  async #resolveEventSource(\n    fn: () => Promise<EventSource>,\n  ): Promise<EventSource> {\n    return await fn().then((maybeEventSource) => {\n      if (!isEventSource(maybeEventSource)) {\n        throw new ClientError(\n          `Error requesting a stream token. Expected a EventSource as the query result, but received ${typeof maybeEventSource}. Your query must return the result of '<Set>.eventSource' or '<Set>.eventsOn')\\n` +\n            `Query result: ${JSON.stringify(maybeEventSource, null)}`,\n        );\n      }\n      return maybeEventSource;\n    });\n  }\n\n  #validateConfiguration() {\n    const config = this.#clientConfiguration;\n\n    const required_options: (keyof FeedClientConfiguration)[] = [\n      \"long_type\",\n      \"httpClient\",\n      \"max_backoff\",\n      \"max_attempts\",\n      \"client_timeout_buffer_ms\",\n      \"query_timeout_ms\",\n      \"secret\",\n    ];\n    required_options.forEach((option) => {\n      if (config[option] === undefined) {\n        throw new TypeError(\n          `ClientConfiguration option '${option}' must be defined.`,\n        );\n      }\n    });\n\n    if (config.max_backoff <= 0) {\n      throw new RangeError(`'max_backoff' must be greater than zero.`);\n    }\n\n    if (config.max_attempts <= 0) {\n      throw new RangeError(`'max_attempts' must be greater than zero.`);\n    }\n\n    if (config.query_timeout_ms <= 0) {\n      throw new RangeError(`'query_timeout_ms' must be greater than zero.`);\n    }\n\n    if (config.client_timeout_buffer_ms < 0) {\n      throw new RangeError(\n        `'client_timeout_buffer_ms' must be greater than or equal to zero.`,\n      );\n    }\n\n    if (config.start_ts !== undefined && config.cursor !== undefined) {\n      throw new TypeError(\n        \"Only one of 'start_ts' or 'cursor' can be defined in the client configuration.\",\n      );\n    }\n\n    if (config.cursor !== undefined && typeof config.cursor !== \"string\") {\n      throw new TypeError(\"'cursor' must be a string.\");\n    }\n  }\n}\n\n// Private types and constants for internal logic.\n\nfunction wait(ms: number) {\n  return new Promise((r) => setTimeout(r, ms));\n}\n"],
  "mappings": "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",
  "names": ["require_base64_js", "__commonJSMin", "exports", "byteLength", "toByteArray", "fromByteArray", "lookup", "revLookup", "Arr", "code", "i", "len", "getLens", "b64", "validLen", "placeHoldersLen", "lens", "_byteLength", "tmp", "arr", "curByte", "tripletToBase64", "num", "encodeChunk", "uint8", "start", "end", "output", "extraBytes", "parts", "maxChunkLength", "len2", "endpoints", "FaunaError", "args", "ServiceError", "failure", "httpStatus", "info", "QueryRuntimeError", "QueryCheckError", "InvalidRequestError", "ConstraintFailureError", "AbortError", "AuthenticationError", "AuthorizationError", "ContendedTransactionError", "ThrottlingError", "QueryTimeoutError", "ServiceInternalError", "ClientError", "message", "options", "ClientClosedError", "NetworkError", "ProtocolError", "error", "getServiceError", "FaunaAPIPaths", "FetchClient", "#baseUrl", "#defaultRequestPath", "FaunaAPIPaths", "#defaultStreamPath", "#keepalive", "url", "fetch_keepalive", "#resolveURL", "path", "data", "requestHeaders", "method", "client_timeout_ms", "signal", "controller", "response", "error", "NetworkError", "status", "responseHeaders", "value", "key", "body", "request", "abortController", "options", "reader", "failure", "getServiceError", "line", "readLines", "textDecoder", "partOfLine", "chunk", "readChunks", "chunkText", "chunkLines", "done", "readResult", "http2", "_clients", "_http2_session_idle_ms", "_http2_max_streams", "_url", "_numberOfUsers", "_session", "_defaultRequestPath", "_defaultStreamPath", "_getClientKey", "getClientKey_fn", "_closeForAll", "closeForAll_fn", "_connect", "connect_fn", "_doRequest", "doRequest_fn", "_doStream", "doStream_fn", "_NodeHTTP2Client", "http2_session_idle_ms", "url", "http2_max_streams", "__privateAdd", "FaunaAPIPaths", "__privateSet", "httpClientOptions", "_a", "clientKey", "__privateMethod", "__privateGet", "client", "__privateWrapper", "req", "retryCount", "memoizedError", "error", "NetworkError", "NodeHTTP2Client", "newSession", "client_timeout_ms", "requestData", "requestHeaders", "method", "path", "resolvePromise", "rejectPromise", "onResponse", "http2ResponseHeaders", "status", "responseData", "chunk", "httpRequestHeaders", "resolveChunk", "rejectChunk", "setChunkPromise", "res", "rej", "chunkPromise", "partOfLine", "chunkLines", "s", "failure", "getServiceError", "self", "reader", "body", "chunks", "getDefaultHTTPClient", "options", "nodeHttp2IsSupported", "NodeHTTP2Client", "FetchClient", "isHTTPResponse", "res", "isStreamClient", "client", "import_base64_js", "yearpart", "monthpart", "daypart", "hourpart", "minsecpart", "decimalpart", "datesplit", "timesplit", "zonesplit", "plaindate", "startsWithPlaindate", "datetime", "TimeStub", "isoString", "datetime", "date", "DateStub", "dateString", "matches", "plaindate", "startsWithPlaindate", "ClientError", "DocumentReference", "coll", "id", "Module", "Document", "obj", "ts", "rest", "NamedDocumentReference", "name", "NamedDocument", "data", "NullDocument", "ref", "cause", "Page", "data", "after", "EmbeddedSet", "SetIterator", "#generator", "client", "initial", "options", "generateFromThunk", "generatePages", "query", "pageable", "FlattenedSetIterator", "setIterator", "generateItems", "currentPage", "fql", "thunk", "result", "page", "item", "isEventSource", "value", "StreamToken", "token", "FeedPage", "events", "cursor", "has_next", "stats", "#toEventIterator", "event", "getServiceError", "TaggedTypeFormat", "input", "encode", "encodeInterpolation", "decodeOptions", "_", "value", "Module", "modName", "id", "DocumentReference", "obj", "Document", "NamedDocument", "ref", "NamedDocumentReference", "NullDocument", "EmbeddedSet", "Page", "bigInt", "DateStub", "TimeStub", "StreamToken", "base64toBuffer", "LONG_MIN", "LONG_MAX", "INT_MIN", "INT_MAX", "encodeMap", "wrapped", "_out", "k", "dateValue", "ClientError", "bufferToBase64", "Query", "encodeValueInterpolation", "encodeQueryInterpolation", "encodeArrayInterpolation", "encodeObjectInterpolation", "base64", "arr", "fql", "queryFragments", "queryArgs", "Query", "#queryFragments", "#interpolatedArgs", "#__phantom", "renderedFragments", "fragment", "i", "arg", "encoded", "TaggedTypeFormat", "x", "packageVersion", "os", "getDriverEnv", "driverEnv", "packageVersion", "isNode", "isBrowser", "isServiceWorker", "getNodeRuntimeEnv", "getBrowserDetails", "getBrowserOsDetails", "_", "val", "entry", "navigator", "browser", "browserVersion", "nameOffset", "verOffset", "ix", "clientStrings", "id", "cs", "osVersion", "matches", "crossGlobal", "detectedEnv", "env", "withRetries", "fn", "maxAttempts", "maxBackoff", "shouldRetry", "attempt", "sleepFn", "backoffMs", "error", "resolve", "isQuerySuccess", "res", "isQueryFailure", "DEFAULT_CLIENT_CONFIG", "_driverEnvHeader", "_clientConfiguration", "_httpClient", "_lastTxnTs", "_isClosed", "_queryWithRetries", "queryWithRetries_fn", "_getError", "getError_fn", "_getSecret", "getSecret_fn", "_getEndpoint", "getEndpoint_fn", "_query", "query_fn", "_setHeaders", "setHeaders_fn", "_validateConfiguration", "validateConfiguration_fn", "_Client", "clientConfiguration", "httpClient", "__privateAdd", "__privateSet", "__privateMethod", "getDefaultHTTPClient", "__privateGet", "ts", "copy", "ClientClosedError", "iterable", "options", "Query", "SetIterator", "query", "request", "TaggedTypeFormat", "tokenOrQuery", "streamClient", "isStreamClient", "streamClientConfig", "ClientError", "tokenOrGetToken", "res", "StreamClient", "FeedClient", "Client", "queryRequest", "queryOptions", "attempt", "maxBackoff", "maxAttempts", "backoffMs", "error", "ThrottlingError", "wait", "NetworkError", "ProtocolError", "ServiceError", "isHTTPResponse", "isQueryFailure", "failure", "status", "getServiceError", "partialClientConfig", "env_secret", "maybeSecret", "env_endpoint", "endpoints", "requestConfig", "headers", "isTaggedFormat", "client_timeout_ms", "response", "parsedResponse", "tags_array", "tag", "isQuerySuccess", "txn_ts", "e", "fromObject", "headerObject", "setHeader", "header", "value", "transform", "v", "tags", "config", "option", "getDriverEnv", "#clientConfiguration", "#connectionAttempts", "#query", "#last_ts", "#last_cursor", "#streamAdapter", "#eventSource", "token", "isEventSource", "#validateConfiguration", "onEvent", "onError", "event", "maybeStreamToken", "#startStream", "FaunaError", "eventSource", "streamAdapter", "deserializedEvent", "_lastCursor", "_eventSource", "_isDone", "_getHeaders", "getHeaders_fn", "_nextPageHttpRequest", "nextPageHttpRequest_fn", "_resolveEventSource", "resolveEventSource_fn", "_FeedClient", "withRetries", "body", "page", "FeedPage", "req", "FaunaAPIPaths", "fn", "maybeEventSource", "ms", "r"]
}
